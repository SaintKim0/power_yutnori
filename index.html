<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- ëª¨ë°”ì¼ ë·°í¬íŠ¸ ì„¤ì •: í™•ëŒ€ ë°©ì§€, ì•± ìŠ¤íƒ€ì¼ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#fbe9e7">
    <meta name="description" content="ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì¦ê¸°ëŠ” í•œêµ­ ì „í†µ ë¯¼ì†ë†€ì´ 'ìœ·ë†€ì´' ê²Œì„">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS ì•„ì´ì½˜ -->
    <link rel="apple-touch-icon" href="/icon-192.png">
    
    <title>íŒŒì›Œ ê²Œì´ì§€ ìœ·ë†€ì´</title>
    <style>
        :root {
            --primary-color: #5d4037;
            --bg-color: #fbe9e7;
            --stick-color: #deb887;
            --board-line-color: #8d6e63;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 3px;
            box-sizing: border-box;
            overflow-x: hidden;
            touch-action: manipulation; /* í„°ì¹˜ ì§€ì—° ì œê±° */
            -webkit-user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
            user-select: none;
            overscroll-behavior: none; /* ìŠ¤í¬ë¡¤ ë°”ìš´ìŠ¤ ë°©ì§€ */
        }

        .app-shell {
            width: 100%;
            max-width: 100%;
            transform: scale(0.85);
            transform-origin: top center;
        }

        h1 {
            color: var(--primary-color);
            margin: 3px 0 5px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            font-size: 1.02rem;
        }

        /* ì„¤ì • ì˜ì—­ */
        #setupArea {
            background: white;
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            margin-top: 20px;
            text-align: center;
            display: block;
            width: 90%;
            max-width: 400px;
            z-index: 10;
        }

        /* ê²Œì„ ì˜ì—­ ë ˆì´ì•„ì›ƒ - ëª¨ë°”ì¼ ì„¸ë¡œ ë°°ì¹˜ ìµœì í™” */
        .game-wrapper {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
            gap: 5px;
            padding-bottom: 3px;
            margin-top: -8px;
        }

        /* ì™¼ìª½: ë³´ë“œ (ë°˜ì‘í˜• ì ìš©) */
        .board-section {
            background: white;
            padding: 8px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            width: 95%; /* ëª¨ë°”ì¼ ê½‰ ì°¨ê²Œ */
            aspect-ratio: 1/1; /* ì •ì‚¬ê°í˜• ìœ ì§€ */
        }

        /* ì˜¤ë¥¸ìª½: ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .control-section {
            background: white;
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
            width: 95%;
            box-sizing: border-box;
        }

        /* ìƒíƒœ í‘œì‹œì¤„ */
        .status-bar {
            background: #eee;
            border-radius: 8px;
            padding: 6px;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .current-turn {
            color: white;
            background-color: #333;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
        }

        /* ìœ·ê°€ë½ */
        .yut-container {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 8px;
            height: 50px;
        }
        .stick {
            width: 20px;
            height: 50px;
            border-radius: 6px;
            border: 2px solid #5d4037;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            background-color: var(--stick-color);
            transition: transform 0.3s;
            position: relative;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }
        .stick.flat { background-color: #fff8e1; color: #333; }
        .stick.flat::after { content: "XXXX"; transform: rotate(90deg); font-size: 8px; letter-spacing: 2px; }
        
        /* ë°±ë„(Back-Do) í‘œì‹œ */
        .stick.back-do-mark::before {
            content: "ë¹½";
            position: absolute;
            top: 4px;
            color: red;
            font-size: 10px;
            font-weight: bold;
            border: 1px solid red;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            line-height: 14px;
            display: block;
        }

        /* ê²Œì´ì§€ */
        .gauge-wrapper {
            position: relative;
            width: 100%;
            height: 30px; /* í„°ì¹˜í•˜ê¸° ì¢‹ê²Œ ì¡°ê¸ˆ í‚¤ì›€ */
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 2px solid #333;
        }
        .zone { position: absolute; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: rgba(0,0,0,0.5); }
        .zone-weak { left: 0; width: 10%; background: #ffcdd2; }
        .zone-safe { left: 10%; width: 80%; background: #e8f5e9; }
        .zone-over { right: 0; width: 10%; background: #ffcdd2; }
        .power-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ff9800, #f44336); position: absolute; top: 0; left: 0; opacity: 0.9; }

        /* ë²„íŠ¼ë“¤ - ëª¨ë°”ì¼ í„°ì¹˜ ìµœì í™” */
        .btn-primary {
            background-color: #d84315; color: white; border: none; padding: 10px;
            font-size: 1rem; border-radius: 10px; cursor: pointer; width: 100%; font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 3px 0 #9f2a08; /* ì…ì²´ê° */
            touch-action: manipulation;
        }
        .btn-primary:active { transform: translateY(4px); box-shadow: none; }
        .btn-primary:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .btn-secondary {
            background-color: #5d4037; color: white; border: none; padding: 12px 20px;
            border-radius: 8px; cursor: pointer; margin: 5px; font-size: 1rem;
        }
        
        .btn-info {
            background-color: #0288d1; color: white; border: none; padding: 12px 20px;
            border-radius: 8px; cursor: pointer; margin-top: 15px; font-size: 1rem; width: 100%;
        }
        
        .btn-sound-toggle {
             background-color: #4caf50; color: white; border: none; padding: 10px;
             border-radius: 8px; cursor: pointer; font-size: 0.9rem; margin-top: 10px; width: 100%;
        }

        .btn-undo {
            background-color: #757575; color: white; border: none; padding: 8px;
            font-size: 0.85rem; border-radius: 8px; cursor: pointer; width: 100%; margin-top: 8px;
            display: none; box-shadow: 0 2px 0 #555;
        }
        .btn-undo:active { transform: translateY(2px); box-shadow: none; }

        /* íŒ¨(Move) ì„ íƒ ë²„íŠ¼ ì˜ì—­ */
        #availableMoves {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            margin-bottom: 8px;
        }
        .move-chip {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid #5d4037;
            background: white;
            font-weight: bold;
            cursor: pointer;
            color: #5d4037;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        .move-chip.selected {
            background: #5d4037;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .move-chip.back-do {
            border-color: red;
            color: red;
        }
        .move-chip.back-do.selected {
            background: red;
            color: white;
        }

        /* ë§ ì„ íƒ ë²„íŠ¼ ì˜ì—­ */
        #moveOptions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 3px;
        }
        .btn-move-token {
            background: white; border: 2px solid #ddd; padding: 8px; border-radius: 10px;
            text-align: left; cursor: pointer; display: flex; align-items: center; gap: 10px;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        .btn-move-token:active { background: #eee; }
        
        /* SVG ë³´ë“œ (ë°˜ì‘í˜•) */
        #yutBoard {
            width: 100%;
            height: 100%; /* ë¶€ëª¨ ì»¨í…Œì´ë„ˆì— ë§ì¶¤ */
            background-color: #fff3e0;
            border-radius: 10px; border: 3px solid #5d4037;
            display: block;
        }
        .board-dot { fill: white; stroke: var(--board-line-color); stroke-width: 2; }
        .board-dot.start { fill: #ffe0b2; stroke: #e65100; stroke-width: 3; }
        .board-dot.corner { fill: #efebe9; }
        .board-dot.center { fill: #d7ccc8; stroke-width: 3; }
        .board-line { stroke: var(--board-line-color); stroke-width: 3; stroke-linecap: round; fill: none;}

        /* ë§ ìŠ¤íƒ€ì¼ */
        .token {
            stroke: white; stroke-width: 2;
            transition: cx 0.5s ease, cy 0.5s ease;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
        }
        .token-text {
            fill: white; font-size: 10px; font-weight: bold; text-anchor: middle; pointer-events: none;
        }

        .result-text { font-size: 1.3rem; font-weight: bold; margin: 5px 0; color: #333; height: 30px;}
        .info-text { color: #666; font-size: 0.85rem; margin-bottom: 6px; }
        
        /* ì„¤ì • ì¸í’‹ ìŠ¤íƒ€ì¼ */
        .input-group { margin: 15px 0; text-align: left; background: #f5f5f5; padding: 15px; border-radius: 12px; }
        .input-group label { font-weight: bold; display: block; margin-bottom: 8px; color: #555; font-size: 1rem;}
        .input-group input,
        .input-group select { width: 100%; padding: 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 1.1rem; box-sizing: border-box;}

        /* ëª¨ë‹¬ (Modal) ìŠ¤íƒ€ì¼ */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            max-width: 450px;
            width: 85%;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            z-index: 1001;
            max-height: 85vh;
            overflow-y: auto;
        }
        .modal-title { font-size: 1.8rem; margin-bottom: 15px; font-weight: bold; color: #d84315; }
        .modal-desc { font-size: 1.1rem; margin-bottom: 25px; color: #555; line-height: 1.6; text-align: left; word-break: keep-all;}
        
        .rule-list { text-align: left; padding-left: 20px; margin-bottom: 20px; color: #444; font-size: 0.95rem; }
        .rule-list li { margin-bottom: 10px; }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* í­ì£½ ìº”ë²„ìŠ¤ */
        #confettiCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 50;
            display: none;
        }

    </style>
</head>
<body>

    <div class="app-shell">
        <h1>ğŸ¥ ëª¨ë°”ì¼ ìœ·ë†€ì´</h1>

    <!-- 1. ì„¤ì • í™”ë©´ -->
    <div id="setupArea">
        <h2 style="margin-top:0;">ê²Œì„ ì„¤ì •</h2>
        
        <div class="input-group">
            <label for="tokenCountInput">ë§ ê°œìˆ˜ (íŒ€ë‹¹)</label>
            <input type="number" id="tokenCountInput" value="2" min="1" max="5" inputmode="numeric">
        </div>

        <div class="input-group">
            <label for="undoCountInput">íŒ€ë³„ ë¬¼ë¦¬ê¸° íšŸìˆ˜</label>
            <input type="number" id="undoCountInput" value="2" min="0" max="10" inputmode="numeric">
        </div>

        <div style="margin-bottom: 20px;">
            <p style="font-weight: bold; color: #555;">ì°¸ê°€í•  íŒ€ (ê¸°ë³¸ 2íŒ€)</p>
            <ul id="teamList" style="list-style: none; padding: 0;">
                <!-- JSë¡œ íŒ€ ë¦¬ìŠ¤íŠ¸ ìƒì„± -->
            </ul>
            <button id="btnAddTeam" class="btn-secondary" style="width:100%" onclick="addTeam()">+ íŒ€ ì¶”ê°€</button>
        </div>

        <div class="input-group">
            <label for="modeSelect">í”Œë ˆì´ ëª¨ë“œ</label>
            <select id="modeSelect">
                <option value="multi">ë©€í‹°í”Œë ˆì´ (ë‹¤ìˆ˜ íŒ€)</option>
                <option value="ai">AIì™€ í”Œë ˆì´ (í˜¼ììš©)</option>
            </select>
        </div>
        
        <button class="btn-primary" onclick="initGame()">ê²Œì„ ì‹œì‘ â–¶</button>
        
        <div style="display:flex; gap:10px; margin-top: 15px;">
            <button class="btn-info" style="margin-top:0; flex:1;" onclick="showRules()">ğŸ“– ë°©ë²•</button>
            <button class="btn-sound-toggle" style="margin-top:0; flex:1;" onclick="SoundEffect.toggleMute()">ğŸ”Š ì†Œë¦¬ ON</button>
        </div>
    </div>

    <!-- 2. ê²Œì„ í™”ë©´ -->
    <div class="game-wrapper" id="gameWrapper">
        <!-- ì™¼ìª½: ë³´ë“œ -->
        <div class="board-section">
            <svg id="yutBoard" viewBox="0 0 400 400">
                <!-- ë³´ë“œ ì„  -->
                <path d="M 350 350 L 350 50 L 50 50 L 50 350 L 350 350" class="board-line" />
                <path d="M 50 50 L 350 350" class="board-line" />
                <path d="M 350 50 L 50 350" class="board-line" />
                
                <!-- ì (Dots) ê·¸ë£¹ -->
                <g id="boardDots"></g>
                
                <!-- ë§(Tokens) ê·¸ë£¹ -->
                <g id="tokenLayer"></g>
            </svg>
        </div>

        <!-- ì˜¤ë¥¸ìª½ ì»¨íŠ¸ë¡¤ -->
        <div class="control-section">
            <div class="status-bar">
                <span id="turnIndicator" class="current-turn">ì²­íŒ€ ì°¨ë¡€</span>
                <span id="gameInfo" style="font-size:0.9rem">ë§ 2ê°œ / 4íŒ€</span>
            </div>

            <!-- ìœ·ê°€ë½ ì‹œê°í™” -->
            <div class="yut-container" id="yutContainer">
                <div class="stick round"></div>
                <div class="stick round"></div>
                <div class="stick round"></div>
                <div class="stick round"></div> <!-- ë°±ë„ í‘œì‹œë  ìœ· -->
            </div>

            <div class="result-text" id="mainResult">ì¤€ë¹„</div>
            <div class="info-text" id="subResult">ë²„íŠ¼ì„ ëˆŒëŸ¬ í˜ì„ ì¡°ì ˆí•˜ì„¸ìš”!</div>

            <!-- íŒŒì›Œ ê²Œì´ì§€ (ë˜ì§ˆ ë•Œë§Œ ë³´ì„) -->
            <div id="gaugeArea">
                <div class="gauge-wrapper">
                    <div class="zone zone-weak">ì•½í•¨</div>
                    <div class="zone zone-safe">ì„±ê³µ</div>
                    <div class="zone zone-over">ë‚™ì¥</div>
                    <div class="power-bar" id="powerBar"></div>
                </div>
                <button class="btn-primary" id="actionBtn" onclick="toggleThrow()">ë˜ì§€ê¸° (START)</button>
            </div>

            <!-- ì´ë™ ì„ íƒ ì˜ì—­ (ì´ë™ ì‹œì—ë§Œ ë³´ì„) -->
            <div id="moveArea" style="display: none;">
                <div style="font-size:0.85rem; font-weight:bold; color:#555; margin-bottom:6px;">íŒ¨ ì„ íƒ</div>
                <div id="availableMoves"></div>
                
                <div style="font-size:0.85rem; font-weight:bold; color:#555; margin-top:10px; margin-bottom:6px;">ì´ë™í•  ë§ ì„ íƒ</div>
                <div id="moveOptions"></div>
            </div>

            <!-- ë¬¼ë¦¬ê¸° ë²„íŠ¼ -->
            <button id="btnUndo" class="btn-undo" onclick="undoLastMove()">â†© ë¬¼ë¦¬ê¸° (2íšŒ ë‚¨ìŒ)</button>
        </div>
    </div>

    <!-- 3. ìŠ¹ë¦¬ ëª¨ë‹¬ -->
    <div id="winModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title" id="winTitle">ìŠ¹ë¦¬!</div>
            <div class="modal-desc" id="winDesc">ëª¨ë“  ë§ì´ ì™„ì£¼í–ˆìŠµë‹ˆë‹¤!</div>
            <button class="btn-primary" onclick="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <!-- 4. ê²Œì„ ë°©ë²• ëª¨ë‹¬ -->
    <div id="ruleModal" class="modal-overlay">
        <div class="modal-content" style="text-align: left;">
            <div class="modal-title" style="text-align: center;">ğŸ“œ ê²Œì„ ë°©ë²•</div>
            <div class="modal-desc">
                <ul class="rule-list">
                    <li><strong>ë˜ì§€ê¸°:</strong> íŒŒì›Œ ê²Œì´ì§€ì˜ ì´ˆë¡ìƒ‰ êµ¬ê°„ì— ë§ì¶° ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”. ë¹¨ê°„ êµ¬ê°„ì€ ì‹¤ê²©ì…ë‹ˆë‹¤.</li>
                    <li><strong>ì´ë™:</strong> ë„(1), ê°œ(2), ê±¸(3), ìœ·(4), ëª¨(5), ë°±ë„(-1)ë§Œí¼ ì´ë™í•©ë‹ˆë‹¤.</li>
                    <li><strong>í•œ ë²ˆ ë”:</strong> 'ìœ·'ì´ë‚˜ 'ëª¨'ëŠ” í•œ ë²ˆ ë” ë˜ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li><strong>ì¡ê¸°:</strong> ìƒëŒ€ë°© ë§ì„ ì¡ìœ¼ë©´ í•œ ë²ˆ ë” ë˜ì§‘ë‹ˆë‹¤.</li>
                    <li><strong>ì§€ë¦„ê¸¸:</strong> ëª¨ì„œë¦¬ë‚˜ ì¤‘ì•™ì— ë©ˆì¶”ë©´ ì§€ë¦„ê¸¸ë¡œ ì´ë™í•©ë‹ˆë‹¤.</li>
                    <li><strong>ìŠ¹ë¦¬:</strong> íŒ€ì˜ ëª¨ë“  ë§ì´ ì¶œë°œì ìœ¼ë¡œ ëŒì•„ì˜¤ë©´ ìŠ¹ë¦¬!</li>
                </ul>
            </div>
            <button class="btn-secondary" style="width: 100%; background:#777;" onclick="closeRules()">ë‹«ê¸°</button>
        </div>
    </div>

    <!-- 5. í­ì£½ ìº”ë²„ìŠ¤ -->
    <canvas id="confettiCanvas"></canvas>
    </div>

    <script>
        // --- 0. ì‚¬ìš´ë“œ ê´€ë¦¬ ê°ì²´ (Web Audio API) ---
        const SoundEffect = {
            ctx: null,
            isMuted: false,

            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            toggleMute: function() {
                this.isMuted = !this.isMuted;
                const btn = document.querySelector('.btn-sound-toggle');
                if(btn) btn.innerText = this.isMuted ? "ğŸ”‡ ì†Œë¦¬ OFF" : "ğŸ”Š ì†Œë¦¬ ON";
            },

            playTone: function(freq, type, duration, startTime = 0) {
                if (this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = type;
                osc.frequency.value = freq;
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime + startTime;
                osc.start(now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                osc.stop(now + duration);
            },

            // íš¨ê³¼ìŒë“¤
            playClick: function() { this.playTone(600, 'sine', 0.1); },
            playStartGauge: function() { 
                if (this.isMuted || !this.ctx) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.3);
                osc.stop(now + 0.3);
            },
            playFail: function() {
                // ë ë¡œë¦¬~ (ë‚´ë ¤ê°€ëŠ” ì†Œë¦¬)
                this.playTone(400, 'sawtooth', 0.2, 0);
                this.playTone(300, 'sawtooth', 0.4, 0.2);
            },
            playYutThrow: function() {
                // ë”©ë™ëŒ• (ì„±ê³µ)
                this.playTone(523.25, 'sine', 0.1, 0); // ë„
                this.playTone(659.25, 'sine', 0.1, 0.1); // ë¯¸
                this.playTone(783.99, 'sine', 0.2, 0.2); // ì†”
            },
            playGoodThrow: function() {
                // ìœ·/ëª¨/ì¡ê¸° (ê°•ì¡°)
                this.playTone(523.25, 'square', 0.1, 0); 
                this.playTone(783.99, 'square', 0.1, 0.1); 
                this.playTone(1046.50, 'square', 0.3, 0.2); 
            },
            playMove: function() {
                this.playTone(800, 'sine', 0.05);
            },
            playCatch: function() {
                // íœ™! í½!
                if (this.isMuted || !this.ctx) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.2);
                osc.stop(now + 0.2);
            },
            playWin: function() {
                // íŒ¡íŒŒë ˆ
                const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50];
                const times = [0, 0.2, 0.4, 0.6, 0.8, 1.0];
                notes.forEach((freq, i) => {
                    this.playTone(freq, 'triangle', 0.3, times[i]);
                });
            }
        };


        // --- 1. ì „ì—­ ì„¤ì • ë° ë°ì´í„° ---
        const TEAM_COLORS = [
            { name: "ì²­íŒ€", code: "#1976d2", text: "Blue" },
            { name: "í™íŒ€", code: "#d32f2f", text: "Red" },
            { name: "ì´ˆë¡íŒ€", code: "#388e3c", text: "Green" },
            { name: "ë…¸ë‘íŒ€", code: "#fbc02d", text: "Yellow" }
        ];

        let teams = [];
        
        // ê²Œì„ ìƒíƒœ
        let gameState = {
            currentTeamIdx: 0,
            step: 'SETUP', // SETUP, THROW, MOVE, END
            moveQueue: [], // [ {score:4, text:'ìœ·', id:123}, ... ]
            selectedMoveId: null, // í˜„ì¬ ì´ë™í•˜ë ¤ê³  ì„ íƒí•œ íŒ¨ì˜ ID
            maxUndos: 2
        };

        // ë¬¼ë¦¬ê¸°(Undo)ë¥¼ ìœ„í•œ ì´ì „ ìƒíƒœ ì €ì¥
        let historyState = null;

        let tokensPerTeam = 2; // ê¸°ë³¸ê°’

        // DOM ìš”ì†Œ
        const setupArea = document.getElementById('setupArea');
        const gameWrapper = document.getElementById('gameWrapper');
        const teamList = document.getElementById('teamList');
        const boardDots = document.getElementById('boardDots');
        const tokenLayer = document.getElementById('tokenLayer');
        const turnIndicator = document.getElementById('turnIndicator');
        const gameInfo = document.getElementById('gameInfo');
        const mainResult = document.getElementById('mainResult');
        const subResult = document.getElementById('subResult');
        const actionBtn = document.getElementById('actionBtn');
        const gaugeArea = document.getElementById('gaugeArea');
        const moveArea = document.getElementById('moveArea');
        const availableMoves = document.getElementById('availableMoves');
        const moveOptions = document.getElementById('moveOptions');
        const powerBar = document.getElementById('powerBar');
        const sticks = document.getElementById('yutContainer').children;
        const btnUndo = document.getElementById('btnUndo');
        const undoCountInput = document.getElementById('undoCountInput');
        const tokenCountInput = document.getElementById('tokenCountInput');
        const winModal = document.getElementById('winModal');
        const winTitle = document.getElementById('winTitle');
        const ruleModal = document.getElementById('ruleModal');
        const modeSelect = document.getElementById('modeSelect');
        const addTeamBtn = document.getElementById('btnAddTeam');

        let gameMode = 'multi';
        let aiTimeoutId = null;
        const aiActionDelay = 1200;

        // --- 2. ì´ˆê¸°í™” ë° ì„¤ì • ë¡œì§ ---
        function renderTeamSetup() {
            teamList.innerHTML = "";
            teams.forEach((t, i) => {
                teamList.innerHTML += `
                    <li style="margin:5px; color:${t.color}; font-weight:bold;">
                        ${t.name}
                        ${t.isAi ? '<span style="font-size:0.75rem; margin-left:8px; color:#d32f2f;">(AI)</span>' : ''}
                        ${i > 1 ? `<button onclick="removeTeam(${i})" style="font-size:0.8rem; cursor:pointer; background:#999; color:white; border:none; padding:4px 8px; border-radius:4px; margin-left:10px;">ì‚­ì œ</button>` : ''}
                    </li>`;
            });
        }

        function initSetup() {
            addTeamData(0);
            addTeamData(1);
            renderTeamSetup();
            modeSelect.value = gameMode;
            addTeamBtn.disabled = (gameMode === 'ai');
            // ë°±ë„ í‘œì‹œ (ë§ˆì§€ë§‰ ìœ·ê°€ë½)
            sticks[3].classList.add('back-do-mark');
        }

        function addTeamData(colorIdx) {
            if (teams.length >= 4) return;
            const c = TEAM_COLORS[colorIdx];
            // í† í° ìƒì„±ì€ ê²Œì„ ì‹œì‘ ì‹œ í™•ì •ëœ ê°œìˆ˜ë¡œ ì¬ìƒì„±í•¨ (ì—¬ê¸°ì„  ì„ì‹œ êµ¬ì¡°ë§Œ)
            teams.push({ 
                id: teams.length, 
                name: c.name, 
                color: c.code, 
                tokens: [],
                remainingUndos: 2,
                isAi: false 
            });
        }

        function addTeam() {
            if (gameMode === 'ai') {
                alert("AI ëª¨ë“œì—ì„œëŠ” íŒ€ì„ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }
            SoundEffect.playClick();
            if (teams.length >= 4) { alert("ìµœëŒ€ 4íŒ€ê¹Œì§€ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."); return; }
            addTeamData(teams.length);
            renderTeamSetup();
        }

        function removeTeam(idx) {
            SoundEffect.playClick();
            teams.splice(idx, 1);
            teams.forEach((t, i) => { t.id = i; t.name = TEAM_COLORS[i].name; t.color = TEAM_COLORS[i].code; });
            renderTeamSetup();
        }

        modeSelect.addEventListener('change', () => {
            gameMode = modeSelect.value;
            addTeamBtn.disabled = (gameMode === 'ai');
            if (gameMode === 'ai' && teams.length > 2) {
                teams = teams.slice(0, 2);
                renderTeamSetup();
            }
        });

        function initGame() {
            SoundEffect.init(); // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì‹œì‘
            SoundEffect.playClick();

            const maxVal = parseInt(undoCountInput.value) || 2;
            tokensPerTeam = parseInt(tokenCountInput.value) || 2;
            
            gameState.maxUndos = maxVal;
            const aiMode = modeSelect.value === 'ai';
            gameMode = modeSelect.value;
            gameState.isSinglePlayer = aiMode;
            if (aiMode) {
                if (teams.length > 2) teams = teams.slice(0, 2);
                while (teams.length < 2) addTeamData(teams.length);
                teams[0].isAi = false;
                teams[0].name = TEAM_COLORS[0].name;
                teams[0].color = TEAM_COLORS[0].code;
                teams[1].isAi = true;
                teams[1].name = "AI";
                teams[1].color = TEAM_COLORS[1].code;
                renderTeamSetup();
            } else {
                teams.forEach((t, i) => {
                    t.isAi = false;
                    t.name = TEAM_COLORS[i % TEAM_COLORS.length].name;
                    t.color = TEAM_COLORS[i % TEAM_COLORS.length].code;
                });
            }
            
            // íŒ€ë³„ ì„¤ì • ì ìš©
            teams.forEach(t => {
                t.remainingUndos = maxVal;
                // ë§ ê°œìˆ˜ì— ë§ì¶° í† í° ì¬ìƒì„±
                t.tokens = [];
                for(let i=0; i<tokensPerTeam; i++) {
                    t.tokens.push({ id: i, index: 0, location: 'outer', finished: false });
                }
            });

            setupArea.style.display = 'none';
            gameWrapper.style.display = 'flex';
            gameState.step = 'THROW';
            gameState.currentTeamIdx = 0;
            gameState.moveQueue = [];
            historyState = null;
            btnUndo.style.display = 'none';
            
            gameInfo.innerText = `ë§ ${tokensPerTeam}ê°œ / ${teams.length}íŒ€${gameMode === 'ai' ? ' Â· AI ëª¨ë“œ' : ''}`;

            drawBoardDots();
            updateBoardVisuals();
            updateTurnUI();
        }

        function showRules() {
            SoundEffect.playClick();
            ruleModal.style.display = 'flex';
        }
        function closeRules() {
            SoundEffect.playClick();
            ruleModal.style.display = 'none';
        }

        // --- 3. ê²Œì„ ë¡œì§ (ìœ· ë˜ì§€ê¸°) ---
        let isCharging = false;
        let power = 0;
        let direction = 1;
        let animId = null;

        function toggleThrow() {
            btnUndo.style.display = 'none';
            historyState = null;

            if (!isCharging) startGauge();
            else stopGauge();
        }

        function startGauge() {
            SoundEffect.playStartGauge();
            isCharging = true;
            actionBtn.innerText = "ë©ˆì¶”ê¸° (STOP)";
            actionBtn.style.backgroundColor = "#d32f2f";
            mainResult.innerText = "í˜ ì¡°ì ˆ ì¤‘...";
            subResult.innerText = "íƒ€ì´ë°ì„ ë§ì¶° ëˆ„ë¥´ì„¸ìš”!";
            for(let s of sticks) s.classList.add('animate-throw');
            loopGauge();
        }

        function loopGauge() {
            if (!isCharging) return;
            power += direction * 2;
            if (power >= 100) { power=100; direction=-1; }
            else if (power <= 0) { power=0; direction=1; }
            powerBar.style.width = power + "%";
            if (power <= 10 || power >= 90) powerBar.style.background = '#ff5252';
            else powerBar.style.background = '#4caf50';
            animId = requestAnimationFrame(loopGauge);
        }

        function stopGauge() {
            isCharging = false;
            cancelAnimationFrame(animId);
            for(let s of sticks) s.classList.remove('animate-throw');
            actionBtn.disabled = true;
            handleThrowResult(power);
        }

        function handleThrowResult(finalPower) {
            power = finalPower;
            powerBar.style.width = finalPower + "%";
            powerBar.style.background = (finalPower <= 10 || finalPower >= 90) ? '#ff5252' : '#4caf50';

            if (finalPower <= 10) {
                SoundEffect.playFail();
                handleFail("âŒ í˜ ë¶€ì¡± (ì‹¤ê²©)", "ë„ˆë¬´ ì•½í–ˆìŠµë‹ˆë‹¤.");
            }
            else if (finalPower >= 90) {
                SoundEffect.playFail();
                handleFail("âš ï¸ ë‚™ì¥!", "í˜ì´ ë„ˆë¬´ ì…ŒìŠµë‹ˆë‹¤.");
            }
            else {
                calculateYutResult();
            }
        }

        function performAiThrow() {
            const currentTeam = teams[gameState.currentTeamIdx];
            if (!currentTeam || !currentTeam.isAi) return;
            aiTimeoutId = null;
            mainResult.innerText = "AIê°€ ë˜ì§€ê³  ìˆìŠµë‹ˆë‹¤...";
            subResult.innerText = "AIê°€ í˜ì„ ì¡°ì ˆ ì¤‘ì´ì—ìš”.";
            const aiPower = Math.floor(Math.random() * 60) + 20;
            setTimeout(() => {
                handleThrowResult(aiPower);
            }, 700);
        }

        function aiExecuteCurrentMove() {
            const currentTeam = teams[gameState.currentTeamIdx];
            if (!currentTeam || !currentTeam.isAi) return;
            const moveObj = gameState.moveQueue.find(m => m.id === gameState.selectedMoveId);
            if (!moveObj) return;
            let best = { idx: -1, value: -Infinity };
            currentTeam.tokens.forEach((token, idx) => {
                if (token.finished) return;
                const evaluation = evaluateAiMove(token, moveObj);
                if (evaluation.value > best.value) {
                    best = { idx, value: evaluation.value };
                }
            });
            if (best.idx === -1) {
                executeMove(-1, moveObj.id);
            } else {
                executeMove(best.idx, moveObj.id);
            }
        }

        function simulateFuturePotential(snapshot) {
            const futureRolls = [1,2,3,4,5];
            let total = 0;
            futureRolls.forEach(roll => {
                const futurePreview = simulateMove({
                    index: snapshot.finalIdx,
                    location: snapshot.loc,
                    finished: snapshot.finished
                }, roll);
                if (futurePreview.invalidMove) return;
                total += futurePreview.finalIdx * 3;
                if (futurePreview.catch) total += 220;
                if (futurePreview.finished) total += 420;
            });
            return total / futureRolls.length;
        }

        function enemyCaptureThreat(snapshot) {
            let threat = 0;
            teams.forEach((team, tIdx) => {
                if (tIdx === gameState.currentTeamIdx) return;
                team.tokens.forEach(enemy => {
                    if (enemy.finished) return;
                    [1,2,3,4,5].forEach(steps => {
                        const enemyPreview = simulateMove(enemy, steps);
                        if (enemyPreview.invalidMove) return;
                        if (enemyPreview.loc === snapshot.loc && enemyPreview.finalIdx === snapshot.finalIdx) {
                            threat += 220 - steps * 10;
                        }
                    });
                });
            });
            return Math.min(Math.max(threat, 0), 400);
        }

        function evaluateAiMove(token, moveObj) {
            const preview = simulateMove(token, moveObj.score);
            if (preview.invalidMove) return { value: -Infinity, preview };
            let value = preview.finalIdx * 4 + moveObj.score * 10;
            if (preview.catch) value += 600;
            if (preview.finished) value += 1600;
            if (moveObj.score >= 4) value += 280;
            if (preview.loc === 'shortcut_1') value += 120;
            if (preview.loc === 'shortcut_2') value += 150;
            value -= enemyCaptureThreat(preview) * 0.6;
            value += simulateFuturePotential(preview) * 0.35;
            if (preview.loc === 'outer' && preview.finalIdx >= 17) value += 250; // nearing ìŠ¹ì 
            return { value, preview };
        }

        function maybeTriggerAi() {
            const currentTeam = teams[gameState.currentTeamIdx];
            if (!currentTeam || !currentTeam.isAi) return;
            if (aiTimeoutId) {
                clearTimeout(aiTimeoutId);
                aiTimeoutId = null;
            }
            if (gameState.step === 'THROW') {
                gaugeArea.style.display = 'none';
                aiTimeoutId = setTimeout(performAiThrow, aiActionDelay);
            } else if (gameState.step === 'MOVE' && gameState.moveQueue.length > 0) {
                aiTimeoutId = setTimeout(() => {
                    aiExecuteCurrentMove();
                }, aiActionDelay);
            }
        }

        function handleFail(title, desc) {
            mainResult.innerText = title;
            mainResult.style.color = "red";
            subResult.innerText = desc;
            setTimeout(() => { nextTurn(); }, 1500);
        }

        function calculateYutResult() {
            let flatCount = 0;
            let results = [];
            
            // 0: ë‘¥ê·¼ë©´(X/ë’·ë©´), 1: í‰í‰í•œë©´(O/ì•ë©´)
            for(let i=0; i<4; i++) {
                let isFlat = Math.random() < 0.55; // 55% í™•ë¥ ë¡œ í‰í‰
                results.push(isFlat);
                if(isFlat) flatCount++;
            }
            
            updateSticks(results);

            let score = 0;
            let text = "";
            let isBackDo = false;

            switch(flatCount) {
                case 1: 
                    // ë„: 1ê°œë§Œ í‰í‰í•¨.
                    // ë§Œì•½ í‰í‰í•œ ê²ƒì´ 4ë²ˆì§¸(ì¸ë±ìŠ¤ 3) ìœ·ì´ë¼ë©´ 'ë°±ë„'
                    if (results[3] === true) {
                        text = "ë°±ë„";
                        score = -1;
                        isBackDo = true;
                    } else {
                        text = "ë„";
                        score = 1;
                    }
                    break;
                case 2: text="ê°œ"; score=2; break;
                case 3: text="ê±¸"; score=3; break;
                case 4: text="ìœ·"; score=4; break;
                case 0: text="ëª¨"; score=5; break;
            }

            if (isBackDo) {
                mainResult.innerText = `ğŸ”™ ${text} !`;
                mainResult.style.color = "red";
            } else {
                mainResult.innerText = `ğŸ‰ ${text} !`;
                mainResult.style.color = "#2e7d32";
            }
            
            gameState.moveQueue.push({ id: Date.now(), score: score, text: text });

            // ì†Œë¦¬ ì¬ìƒ
            if (score >= 4) SoundEffect.playGoodThrow(); // ìœ·,ëª¨
            else SoundEffect.playYutThrow(); // ë„,ê°œ,ê±¸,ë°±ë„

            if (score >= 4) {
                subResult.innerText = "ìœ·/ëª¨! í•œ ë²ˆ ë” ë˜ì§€ì„¸ìš”.";
                setTimeout(() => {
                    actionBtn.disabled = false;
                    actionBtn.innerText = "ë˜ì§€ê¸° (í•œë²ˆ ë”!)";
                    updateAvailableMovesUI();
                    if (teams[gameState.currentTeamIdx]?.isAi) {
                        setTimeout(maybeTriggerAi, 300);
                    }
                }, 1000);
            } else {
                subResult.innerText = "ì´ë™í•  ë§ì„ ì„ íƒí•˜ì„¸ìš”.";
                setTimeout(() => {
                    prepareMoveStep();
                }, 800);
            }
        }

        function updateSticks(results) {
            for(let i=0; i<4; i++) {
                sticks[i].className = 'stick';
                // ë°±ë„ í‘œì‹œ ìœ ì§€ (4ë²ˆì§¸ ìœ·)
                if (i === 3) sticks[i].classList.add('back-do-mark');
                
                if(results[i]) sticks[i].classList.add('flat');
                else sticks[i].classList.add('round');
            }
        }

        // --- 4. ê²Œì„ ë¡œì§ (ë§ ì´ë™ ì„ íƒ) ---

        function prepareMoveStep() {
            gameState.step = 'MOVE';
            gaugeArea.style.display = 'none';
            moveArea.style.display = 'block';
            
            updateAvailableMovesUI();
            
            if (gameState.moveQueue.length > 0 && !gameState.selectedMoveId) {
                selectMove(gameState.moveQueue[0].id);
            } else if (gameState.moveQueue.length === 0) {
                 nextTurn();
            }
            maybeTriggerAi();
        }

        function updateAvailableMovesUI() {
            availableMoves.innerHTML = "";
            gameState.moveQueue.forEach((move, idx) => {
                const chip = document.createElement('div');
                chip.className = 'move-chip';
                chip.innerText = move.text;
                if (move.score === -1) chip.classList.add('back-do');
                if (move.id === gameState.selectedMoveId) {
                    chip.classList.add('selected');
                }
                chip.onclick = () => {
                    if (gameState.step === 'MOVE') {
                        SoundEffect.playClick();
                        selectMove(move.id);
                    }
                };
                availableMoves.appendChild(chip);
            });
        }

        function selectMove(moveId) {
            gameState.selectedMoveId = moveId;
            updateAvailableMovesUI(); 
            renderTokenOptions(); 
        }

        function renderTokenOptions() {
            moveOptions.innerHTML = "";
            const currentTeam = teams[gameState.currentTeamIdx];
            
            const moveObj = gameState.moveQueue.find(m => m.id === gameState.selectedMoveId);
            if (!moveObj) return;

            const score = moveObj.score;
            let validOptionCount = 0;

            currentTeam.tokens.forEach((token, idx) => {
                if (token.finished) return;

                const btn = document.createElement('button');
                btn.className = 'btn-move-token';
                
                let locText = token.index === 0 ? "ì¶œë°œì " : `${token.index}ë²ˆ`;
                if (token.location !== 'outer') locText = "ì§€ë¦„ê¸¸";
                
                const preview = simulateMove(token, score);
                
                let destText;
                if (preview.invalidMove) {
                     destText = "ğŸš« ì´ë™ë¶ˆê°€";
                     btn.disabled = true;
                     btn.style.opacity = "0.6";
                } else if (preview.finished) {
                    destText = "ğŸ ì™„ì£¼!";
                    validOptionCount++;
                } else {
                    destText = `${preview.finalIdx}ë²ˆìœ¼ë¡œ`;
                    if (preview.catch) destText += " (ì¡ìŒ!)";
                    validOptionCount++;
                }

                btn.innerHTML = `
                    <div style="width:20px; height:20px; border-radius:50%; background:${currentTeam.color}; border:2px solid rgba(0,0,0,0.1);"></div>
                    <div style="flex:1;">
                        <div style="font-weight:bold; font-size:0.85rem;">ë§ ${idx+1} (${locText})</div>
                        <div style="font-size:0.75rem; color:#666;">â®• ${destText}</div>
                    </div>
                `;
                if (!preview.invalidMove) {
                    btn.onclick = () => executeMove(idx, moveObj.id);
                }
                moveOptions.appendChild(btn);
            });

            // ì„ íƒí•œ íŒ¨ë¡œ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ë§ì´ í•˜ë‚˜ë„ ì—†ëŠ” ê²½ìš° ì²˜ë¦¬
            if (validOptionCount === 0) {
                 subResult.innerText = "ì´ë™í•  ìˆ˜ ì—†ëŠ” íŒ¨ì…ë‹ˆë‹¤. (ì†Œë©¸)";
                 setTimeout(() => {
                     executeMove(-1, moveObj.id); 
                 }, 1500);
            }
        }

        // ì´ë™ ì‹œë®¬ë ˆì´ì…˜ (ë°±ë„ í¬í•¨)
        function simulateMove(token, steps) {
            let sim = { 
                idx: token.index, 
                loc: token.location, 
                finished: false, 
                catch: false, 
                finalIdx: 0,
                invalidMove: false,
                movedForward: false,
                canTakeShortcut: false
            };

            // ë°±ë„ ì²˜ë¦¬ (steps === -1)
            if (steps === -1) {
                if (sim.loc === 'outer') {
                    if (sim.idx === 0) {
                        // ì¶œë°œì ì—ì„œ ë°±ë„ -> ì´ë™ ë¶ˆê°€
                        sim.invalidMove = true;
                        return sim;
                    } else if (sim.idx === 1) {
                         // 1ë²ˆì—ì„œ ë°±ë„ -> 20ë²ˆ(ë„ì°©ì )ìœ¼ë¡œ ì´ë™
                         sim.idx = 20;
                    } else {
                        sim.idx--;
                    }
                } else if (sim.loc === 'shortcut_1') {
                    if (sim.idx === 21) { sim.idx = 5; sim.loc = 'outer'; } // ë‹¤ì‹œ ì½”ë„ˆë¡œ
                    else if (sim.idx === 23) sim.idx = 22; // ì¤‘ì•™ì—ì„œ ë’¤ë¡œ
                    else sim.idx--;
                } else if (sim.loc === 'shortcut_2') {
                    if (sim.idx === 26) { sim.idx = 10; sim.loc = 'outer'; }
                    else if (sim.idx === 23) sim.idx = 27; // ì¤‘ì•™ì—ì„œ ë’¤ë¡œ
                    else sim.idx--;
                }
            } else {
                // ì¼ë°˜ ì´ë™
                let forward = false;
                for(let i=0; i<steps; i++) {
                    forward = true;
                    if (sim.loc === 'outer') {
                        sim.idx++;
                        if (sim.idx > 20) { sim.finished = true; break; }
                        if (sim.idx === 10 && i < steps - 1) sim.canTakeShortcut = true;
                    } 
                    else if (sim.loc === 'shortcut_1') {
                        if (sim.idx === 5) sim.idx = 21;
                        else if (sim.idx === 25) { sim.idx = 15; sim.loc = 'outer'; }
                        else sim.idx++;
                    }
                    else if (sim.loc === 'shortcut_2') {
                        if (sim.idx === 10) sim.idx = 26;
                        else if (sim.idx === 27) sim.idx = 23; 
                        else if (sim.idx === 23) sim.idx = 28;
                        else if (sim.idx === 29) { sim.idx = 20; sim.loc = 'outer'; }
                        else sim.idx++;
                    }
                }
                sim.movedForward = forward;
            }
            
            // ë„ì°©ì§€ì—ì„œ ì§€ë¦„ê¸¸ íŒì •
            if (!sim.finished && !sim.invalidMove) {
                 if (sim.loc === 'outer') {
                    if (sim.idx === 5 && sim.movedForward) {
                        sim.loc = 'shortcut_1';
                        sim.idx = 21;
                    } else if (sim.idx === 10 && sim.canTakeShortcut) {
                        sim.loc = 'shortcut_2';
                        sim.idx = 26;
                    }
                } else if (sim.loc === 'shortcut_1' && sim.idx === 23) {
                    sim.loc = 'shortcut_2';
                }
            }
            sim.finalIdx = sim.idx;

            // ì¡ê¸° ì—¬ë¶€ ì²´í¬
            if(!sim.finished && !sim.invalidMove) {
                teams.forEach((t, tIdx) => {
                    if (tIdx === gameState.currentTeamIdx) return;
                    t.tokens.forEach(enemy => {
                        // ìƒëŒ€ ë§ì´ ì™„ì£¼í•˜ì§€ ì•Šì•˜ê³ , ì‹œì‘ì ì´ ì•„ë‹ˆê³ , ìœ„ì¹˜ê°€ ê°™ìœ¼ë©´
                        if (!enemy.finished && enemy.index !== 0 && 
                            enemy.index === sim.finalIdx && enemy.location === sim.loc) {
                            sim.catch = true;
                        }
                    });
                });
            }
            return sim;
        }

        // --- 5. ì´ë™ ì‹¤í–‰ ë° ë¬¼ë¦¬ê¸° ë¡œì§ ---

        function cloneGame() {
            return JSON.parse(JSON.stringify({
                teams: teams,
                gameState: gameState
            }));
        }

        function restoreGame(snapshot) {
            teams = snapshot.teams;
            gameState = snapshot.gameState;
        }

        function executeMove(tokenIdx, moveId) {
            historyState = {
                gameSnapshot: cloneGame(),
                whoMovedIdx: gameState.currentTeamIdx
            };

            const moveIndex = gameState.moveQueue.findIndex(m => m.id === moveId);
            const score = gameState.moveQueue[moveIndex].score;
            gameState.moveQueue.splice(moveIndex, 1);
            gameState.selectedMoveId = null;

            let caughtSomething = false;
            let currentTeam = teams[gameState.currentTeamIdx];

            if (tokenIdx !== -1) {
                SoundEffect.playMove(); // ì´ë™ ì†Œë¦¬
                const selectedToken = currentTeam.tokens[tokenIdx];
                
                // ê°™ì€ ìœ„ì¹˜ì— ìˆëŠ” ê°™ì€ íŒ€ì˜ ë§ë“¤ ì°¾ê¸° (ì¶œë°œì  ì œì™¸)
                const tokensToMove = [];
                if (selectedToken.index === 0) {
                    // ì¶œë°œì ì—ì„œëŠ” ì„ íƒí•œ ë§ë§Œ ì´ë™
                    tokensToMove.push(selectedToken);
                } else {
                    // ê°™ì€ ìœ„ì¹˜ì— ìˆëŠ” ëª¨ë“  ë§ ì°¾ê¸°
                    currentTeam.tokens.forEach((token, idx) => {
                        if (!token.finished && 
                            token.index === selectedToken.index && 
                            token.location === selectedToken.location) {
                            tokensToMove.push(token);
                        }
                    });
                }
                
                // ëª¨ë“  ë§ë“¤ì„ í•¨ê»˜ ì´ë™
                let anyFinished = false;
                tokensToMove.forEach(token => {
                    const result = simulateMove(token, score);
                    
                    token.index = result.finalIdx;
                    token.location = result.loc;
                    token.finished = result.finished;
                    
                    if (result.catch) {
                        teams.forEach((t, tIdx) => {
                            if (tIdx === gameState.currentTeamIdx) return;
                            t.tokens.forEach(enemy => {
                                if (!enemy.finished && enemy.index !== 0 &&
                                    enemy.index === token.index && enemy.location === token.location) {
                                    enemy.index = 0;
                                    enemy.location = 'outer';
                                    caughtSomething = true;
                                }
                            });
                        });
                    }
                    
                    if (token.finished) {
                        anyFinished = true;
                    }
                });
                
                if (anyFinished) {
                    SoundEffect.playGoodThrow(); // ì™„ì£¼ ì‹œ ì¢‹ì€ ì†Œë¦¬
                    subResult.innerText = tokensToMove.length > 1 ? 
                        `${tokensToMove.length}ê°œì˜ ë§ì´ ì™„ì£¼í–ˆìŠµë‹ˆë‹¤!` : 
                        "ë§ì´ ì™„ì£¼í–ˆìŠµë‹ˆë‹¤!";
                }
            }

            updateBoardVisuals();
            
            // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸
            if (checkWin()) {
                return;
            }

            if (currentTeam.remainingUndos > 0) {
                btnUndo.innerText = `â†© ë¬¼ë¦¬ê¸° (ë‚¨ì€ íšŸìˆ˜: ${currentTeam.remainingUndos})`;
                btnUndo.style.display = 'block';
                btnUndo.onclick = undoLastMove;
            } else {
                btnUndo.style.display = 'none';
            }

            if (caughtSomething) {
                SoundEffect.playCatch(); // ì¡ê¸° ì†Œë¦¬
                mainResult.innerText = "ì¡ì•˜ë‹¤!";
                subResult.innerText = "ë§ì´ ì´ë™í•©ë‹ˆë‹¤...";
                moveArea.style.display = 'none'; 
                gaugeArea.style.display = 'none';

                setTimeout(() => {
                    subResult.innerText = "ìƒëŒ€ ë§ì„ ì¡ì•„ì„œ í•œ ë²ˆ ë” ë˜ì§‘ë‹ˆë‹¤!";
                    gameState.step = 'THROW';
                    gaugeArea.style.display = 'block';
                    actionBtn.disabled = false;
                    actionBtn.innerText = "ë˜ì§€ê¸° (ì¡ê¸° ë³´ë„ˆìŠ¤)";
                    maybeTriggerAi();
                }, 800);
                return;
            }

            if (gameState.moveQueue.length > 0) {
                prepareMoveStep();
            } else {
                setTimeout(nextTurn, 1000);
            }
        }
        
        function checkWin() {
            const currentTeam = teams[gameState.currentTeamIdx];
            const isAllFinished = currentTeam.tokens.every(token => token.finished);
            
            if (isAllFinished) {
                gameState.step = 'END';
                showWinModal(currentTeam);
                return true;
            }
            return false;
        }

        function showWinModal(team) {
            SoundEffect.playWin(); // ìŠ¹ë¦¬ ì†Œë¦¬
            winTitle.innerText = `${team.name} ìŠ¹ë¦¬!`;
            winTitle.style.color = team.color;
            winModal.style.display = 'flex'; // ëª¨ë‹¬ ë³´ì´ê¸°
            fireConfetti();
        }

        // --- 6. í­ì£½ íš¨ê³¼ ---
        function fireConfetti() {
            const canvas = document.getElementById('confettiCanvas');
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const pieces = [];
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];

            for(let i=0; i<200; i++) {
                pieces.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height, 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 10 + 5,
                    speedY: Math.random() * 3 + 2,
                    speedX: Math.random() * 2 - 1,
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5
                });
            }

            function animate() {
                if (gameState.step !== 'END') return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pieces.forEach(p => {
                    p.y += p.speedY;
                    p.x += p.speedX;
                    p.rotation += p.rotationSpeed;

                    if (p.y > canvas.height) {
                        p.y = -20;
                        p.x = Math.random() * canvas.width;
                    }

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation * Math.PI / 180);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    ctx.restore();
                });
                requestAnimationFrame(animate);
            }
            animate();
        }

        function undoLastMove() {
            if (!historyState) return;

            SoundEffect.playClick();
            const teamIdx = historyState.whoMovedIdx;
            const team = teams[teamIdx];

            if (team.remainingUndos <= 0) {
                alert("ë¬¼ë¦¬ê¸° íšŸìˆ˜ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.");
                return;
            }

            restoreGame(historyState.gameSnapshot);
            teams[teamIdx].remainingUndos--;
            
            historyState = null;
            btnUndo.style.display = 'none';
            mainResult.innerText = "ë¬¼ë¦¬ê¸° ì‚¬ìš©!";
            subResult.innerText = "ì´ì „ ìƒíƒœë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.";

            updateBoardVisuals();
            updateTurnUI();
            
            if (gameState.step === 'MOVE') {
                gaugeArea.style.display = 'none';
                moveArea.style.display = 'block';
                updateAvailableMovesUI();
                renderTokenOptions();
            } else if (gameState.step === 'THROW') {
                gaugeArea.style.display = 'block';
                moveArea.style.display = 'none';
                actionBtn.disabled = false;
                
                if (gameState.moveQueue.length > 0) { 
                    actionBtn.innerText = "ë˜ì§€ê¸° (ì¡ê¸° ë³´ë„ˆìŠ¤)";
                } else {
                    actionBtn.innerText = "ë˜ì§€ê¸° (START)";
                }
            }
        }

        function nextTurn() {
            gameState.currentTeamIdx++;
            if (gameState.currentTeamIdx >= teams.length) gameState.currentTeamIdx = 0;
            
            gameState.step = 'THROW';
            gameState.moveQueue = [];
            gameState.selectedMoveId = null;
            
            updateTurnUI();
            
            gaugeArea.style.display = 'block';
            moveArea.style.display = 'none';
            availableMoves.innerHTML = "";
            actionBtn.disabled = false;
            actionBtn.innerText = "ë˜ì§€ê¸° (START)";
            mainResult.innerText = "ì¤€ë¹„";
            subResult.innerText = "ë²„íŠ¼ì„ ëˆŒëŸ¬ í˜ì„ ì¡°ì ˆí•˜ì„¸ìš”!";
            
            for(let s of sticks) {
                s.className = 'stick';
                if (sticks[3] === s) s.classList.add('back-do-mark');
                else s.classList.add('round'); 
            }
             for(let i=0; i<4; i++) {
                sticks[i].className = 'stick round';
                if (i===3) sticks[i].classList.add('back-do-mark');
             }
        }

        function updateTurnUI() {
            const currentTeam = teams[gameState.currentTeamIdx];
            const aiSuffix = currentTeam.isAi ? " (AI)" : "";
            turnIndicator.innerText = `${currentTeam.name}${aiSuffix} ì°¨ë¡€`;
            turnIndicator.style.backgroundColor = currentTeam.color;
            actionBtn.style.backgroundColor = currentTeam.color;

            if (currentTeam.isAi && gameState.step === 'THROW') {
                actionBtn.disabled = true;
                actionBtn.innerText = "AIê°€ ë˜ì§€ê³  ìˆìŠµë‹ˆë‹¤...";
                gaugeArea.style.display = 'none';
            } else if (gameState.step === 'THROW') {
                gaugeArea.style.display = 'block';
            }
            maybeTriggerAi();
        }

        // --- 5. ë³´ë“œ ê·¸ë¦¬ê¸° (ê¸°ì¡´ ë™ì¼) ---
        const outerPath = [
            {x: 350, y: 350}, // 0
            {x: 350, y: 290}, {x: 350, y: 230}, {x: 350, y: 170}, {x: 350, y: 110},
            {x: 350, y: 50},  // 5
            {x: 290, y: 50}, {x: 230, y: 50}, {x: 170, y: 50}, {x: 110, y: 50},
            {x: 50, y: 50},   // 10
            {x: 50, y: 110}, {x: 50, y: 170}, {x: 50, y: 230}, {x: 50, y: 290},
            {x: 50, y: 350},  // 15
            {x: 110, y: 350}, {x: 170, y: 350}, {x: 230, y: 350}, {x: 290, y: 350},
            {x: 350, y: 350}  // 20
        ];

        function getCoords(idx, loc) {
            if (loc === 'shortcut_1') {
                if (idx === 5) return outerPath[5];
                const map = { 21: {x:300, y:100}, 22: {x:250, y:150}, 23: {x:200, y:200}, 24: {x:150, y:250}, 25: {x:100, y:300} };
                return map[idx] || outerPath[idx] || {x:350,y:350};
            }
            if (loc === 'shortcut_2') {
                if (idx === 10) return outerPath[10];
                const map = { 26: {x:100, y:100}, 27: {x:150, y:150}, 23: {x:200, y:200}, 28: {x:250, y:250}, 29: {x:300, y:300} };
                return map[idx] || outerPath[idx] || {x:350,y:350};
            }
            return outerPath[idx] || {x:350, y:350};
        }

        function drawBoardDots() {
            boardDots.innerHTML = "";
            outerPath.forEach((pos, i) => { if (i===20) return; createDot(pos.x, pos.y, i); });
            createDot(300, 100, 21); createDot(250, 150, 22); createDot(200, 200, 'center');
            createDot(150, 250, 24); createDot(100, 300, 25);
            createDot(100, 100, 26); createDot(150, 150, 27); createDot(250, 250, 28); createDot(300, 300, 29);
        }

        function createDot(cx, cy, id) {
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", 7);
            c.setAttribute("class", "board-dot");
            if(id===0) c.classList.add('start');
            if(id==='center') c.classList.add('center');
            if([5,10,15].includes(id)) c.classList.add('corner');
            boardDots.appendChild(c);
        }

        function updateBoardVisuals() {
            tokenLayer.innerHTML = "";
            let occupied = {};
            teams.forEach((team) => {
                team.tokens.forEach((token) => {
                    if (token.finished) return;
                    if (token.index === 0) {
                        drawToken(token, team.color, 360 + (team.id * 10), 360 - (token.id * 10)); 
                        return;
                    }
                    const key = `${token.location}_${token.index}`;
                    if (!occupied[key]) occupied[key] = 0;
                    const offset = occupied[key] * 5; 
                    occupied[key]++;
                    const pos = getCoords(token.index, token.location);
                    drawToken(token, team.color, pos.x + offset, pos.y - offset);
                });
            });
        }

        function drawToken(token, color, cx, cy) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", cx); circle.setAttribute("cy", cy); circle.setAttribute("r", 10);
            circle.setAttribute("fill", color); circle.setAttribute("class", "token");
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", cx); text.setAttribute("y", cy); text.setAttribute("dy", 3);
            text.setAttribute("class", "token-text"); text.textContent = token.id + 1;
            g.appendChild(circle); g.appendChild(text); tokenLayer.appendChild(g);
        }

        initSetup();

        // PWA Service Worker ë“±ë¡
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker ë“±ë¡ ì„±ê³µ:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker ë“±ë¡ ì‹¤íŒ¨:', error);
                    });
            });
        }
    </script>
</body>
</html>