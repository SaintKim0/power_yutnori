<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#f5f5f7">
    <meta name="description" content="ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì¦ê¸°ëŠ” í•œêµ­ ì „í†µ ë¯¼ì†ë†€ì´ 'ìœ·ë†€ì´' ê²Œì„">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <title>íŒŒì›Œ ê²Œì´ì§€ ìœ·ë†€ì´</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary-color: #3a2d28;
            --bg-color: #f5f5f7;
            --accent-color: #0071e3;
            --stick-color: #d2b48c;
            --board-line-color: #8d6e63;
            --card-bg: rgba(255, 255, 255, 0.8);
            --glass-bg: rgba(255, 255, 255, 0.7);
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* ìœ„ìª½ ì •ë ¬ */
            min-height: 100dvh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #1d1d1f;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            overscroll-behavior: none;
        }

        .app-shell {
            width: 100%;
            max-width: 500px;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 10px calc(20px + env(safe-area-inset-bottom)); /* í•˜ë‹¨ ì—¬ë°± ëŒ€í­ ê°•í™” */
            box-sizing: border-box;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            -webkit-overflow-scrolling: touch;
        }
        .app-shell::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        h1 {
            color: var(--primary-color);
            margin: 10px 0;
            font-weight: 700;
            letter-spacing: -0.02em;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        #setupArea, .control-section, .board-section {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            border: 1px solid rgba(255,255,255,0.3);
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
        }

        #setupArea { 
            max-width: 400px; 
            text-align: center;
            margin: 10px 0; /* margin: auto ëŒ€ì‹  ì—¬ë°± ì§€ì • */
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .game-wrapper {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            height: 100%;
            gap: 10px;
            flex: 1;
            overflow: hidden;
        }

        .board-section {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: var(--board-size, 100vw);
            max-height: var(--board-size, 100vw);
            aspect-ratio: 1/1;
            padding: 0;
            flex-shrink: 1;
            margin: 0 auto;
        }

        .control-section { 
            width: 100%; 
            max-width: 450px;
            text-align: center;
            flex-shrink: 0;
            margin-top: 0;
        }

        .status-bar {
            background: rgba(0,0,0,0.03);
            border-radius: 14px;
            padding: 4px 10px;
            margin-bottom: 6px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .current-turn {
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .yut-container {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 4px;
            height: 40px;
        }
        .stick {
            width: 16px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #5d4037;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10px;
            background-color: var(--stick-color);
            transition: transform 0.3s;
            position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.15);
        }
        .stick.flat { background-color: #fff8e1; color: #333; }
        .stick.flat::after { content: "XXXX"; transform: rotate(90deg); font-size: 7px; letter-spacing: 1px; opacity: 0.6; }
        .stick.back-do-mark::before {
            content: "ë¹½";
            position: absolute;
            top: 2px;
            color: #ff3b30;
            font-size: 9px;
            font-weight: bold;
            border: 1px solid #ff3b30;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            line-height: 12px;
            display: block;
        }

        .gauge-wrapper {
            position: relative;
            width: 100%;
            height: 24px;
            background: rgba(0,0,0,0.05);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .power-bar { 
            height: 100%; width: 0%; 
            background: linear-gradient(90deg, #34c759, #ff3b30);
            position: absolute; top: 0; left: 0; 
            transition: width 0.05s linear;
        }
        .zone { position: absolute; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 600; color: rgba(0,0,0,0.3); }
        .zone-weak { left: 0; width: 10%; background: rgba(255, 59, 48, 0.05); }
        .zone-safe { left: 10%; width: 80%; background: rgba(52, 199, 89, 0.05); }
        .zone-over { right: 0; width: 10%; background: rgba(255, 59, 48, 0.05); }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px;
            font-size: 0.85rem;
            border-radius: 14px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 4px 12px rgba(0, 113, 227, 0.25);
        }
        .btn-primary:active { transform: scale(0.97); opacity: 0.9; }
        .btn-primary:disabled { background-color: #d1d1d6; box-shadow: none; transform: none; }
        
        .btn-secondary {
            background-color: #8e8e93; color: white; border: none; padding: 10px 16px;
            border-radius: 12px; cursor: pointer; margin: 4px; font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn-secondary:active { transform: scale(0.95); }

        .btn-info {
            background-color: var(--accent-color); color: white; border: none; padding: 10px 16px;
            border-radius: 12px; cursor: pointer; margin-top: 10px; font-size: 0.9rem; width: 100%;
            font-weight: 600;
        }
        
        .btn-sound-toggle {
            background-color: #34c759; color: white; border: none; padding: 10px;
            border-radius: 12px; cursor: pointer; font-size: 0.85rem; margin-top: 8px; width: 100%;
            font-weight: 600;
        }

        .btn-undo {
            background-color: #f2f2f7; color: #1d1d1f; border: 1px solid rgba(0,0,0,0.1); padding: 12px;
            font-size: 1.2rem; border-radius: 14px; cursor: pointer; flex: 1; margin-top: 0;
            font-weight: 600; display: none;
            transition: all 0.2s;
            align-items: center; justify-content: center;
        }
        .btn-undo:active { transform: scale(0.98); background: #e5e5ea; }

        .move-chip {
            padding: 4px 12px;
            border-radius: 18px;
            border: 1px solid rgba(0,0,0,0.1);
            background: white;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            color: #1d1d1f;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .move-chip.selected {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            box-shadow: 0 4px 12px rgba(0, 113, 227, 0.2);
        }
        .move-chip.back-do { border-color: #ff3b30; color: #ff3b30; }
        .move-chip.back-do.selected { background: #ff3b30; color: white; border-color: #ff3b30; }

        #moveOptions { display: flex; flex-direction: row; gap: 6px; margin-top: 4px; width: 100%; justify-content: center; }
        .btn-move-token {
            flex: 1; background: white; border: 1px solid rgba(0,0,0,0.1); padding: 10px 6px; border-radius: 14px;
            text-align: center; cursor: pointer; display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 6px;
            transition: all 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.03); min-width: 0;
        }
        .btn-move-token:active { background: #f2f2f7; transform: scale(0.98); }

        #yutBoard { width: 100%; height: 100%; background-color: #fffcf5; border-radius: 16px; border: 2px solid #5d4037; display: block; }
        .board-dot { fill: white; stroke: var(--board-line-color); stroke-width: 2; }
        .board-dot.start { fill: #ffe0b2; stroke: #ff9500; stroke-width: 3; }
        .board-dot.corner { fill: #f2f2f7; }
        .board-dot.center { fill: #e5e5ea; stroke-width: 3; }
        .board-line { stroke: var(--board-line-color); stroke-width: 2.5; stroke-linecap: round; fill: none; opacity: 0.6;}

        .token {
            stroke: white; stroke-width: 2;
            transition: cx 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), cy 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.2));
        }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake { animation: shake 0.4s; }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #000000;
                --primary-color: #f5f5f7;
                --board-line-color: #a1887f;
                --card-bg: rgba(28, 28, 30, 0.8);
            }
            body { background-color: var(--bg-color); color: #f5f5f7; }
            #setupArea, .control-section, .board-section {
                background: var(--card-bg); border: 1px solid rgba(255,255,255,0.1);
            }
            .status-bar { background: rgba(255,255,255,0.05); }
            .move-chip { background: #2c2c2e; color: #f5f5f7; border-color: rgba(255,255,255,0.1); }
            .btn-move-token { background: #2c2c2e; color: #f5f5f7; border-color: rgba(255,255,255,0.1); }
            .btn-move-token:active { background: #3a3a3c; }
            #yutBoard { background-color: #1c1c1e; border-color: #3a2d28; }
            .input-group { background: rgba(255,255,255,0.05); }
            .input-group input, .input-group select { background: #2c2c2e; color: white; border-color: rgba(255,255,255,0.1); }
            .skill-container { background: rgba(255,255,255,0.05); }
            .btn-skill { background: #2c2c2e; color: white; border-color: rgba(255,255,255,0.1); }
            .btn-undo { background: #2c2c2e; color: #f5f5f7; border-color: rgba(255,255,255,0.1); }
        }

        .result-text { font-size: 1rem; font-weight: 700; margin: 4px 0; color: #1d1d1f; height: 24px; letter-spacing: -0.01em;}
        @media (prefers-color-scheme: dark) { .result-text { color: #f5f5f7; } }
        .info-text { color: #86868b; font-size: 0.75rem; margin-bottom: 4px; }
        
        .input-group { margin: 8px 0; text-align: left; background: rgba(0,0,0,0.03); padding: 12px; border-radius: 18px; flex: 1; }
        .input-row { display: flex; gap: 10px; width: 100%; }
        .input-group label { font-weight: 600; display: block; margin-bottom: 4px; color: #3a3a3c; font-size: 0.8rem;}
        @media (prefers-color-scheme: dark) { .input-group label { color: #f5f5f7; } }
        .input-group input:not([type="checkbox"]),
        .input-group select { 
            width: 100%; padding: 10px 12px; border: 1px solid rgba(0,0,0,0.1); 
            border-radius: 12px; font-size: 0.85rem; box-sizing: border-box; 
            background: white; -webkit-appearance: none; appearance: none;
        }
        .input-group select option { font-size: 0.85rem; }

        /* íŒ€ ë¦¬ìŠ¤íŠ¸ ê°€ë¡œ ë°°ì—´ */
        #teamList { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; padding: 0; margin: 10px 0; }
        .team-item { 
            background: white; padding: 6px 12px; border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);
            display: flex; align-items: center; gap: 6px; font-weight: 700; font-size: 0.85rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        @media (prefers-color-scheme: dark) { .team-item { background: #2c2c2e; border-color: rgba(255,255,255,0.1); } }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center;
            z-index: 1000; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .modal-content {
            background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            padding: 30px; border-radius: 32px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.4); max-width: 450px; width: 85%;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; z-index: 1001; max-height: 85vh; overflow-y: auto;
        }
        @media (prefers-color-scheme: dark) { .modal-content { background: rgba(28, 28, 30, 0.85); border: 1px solid rgba(255,255,255,0.1); color: #f5f5f7; } }
        .modal-title { font-size: 1.6rem; margin-bottom: 12px; font-weight: 800; color: var(--accent-color); letter-spacing: -0.02em; }
        .modal-desc { font-size: 0.95rem; margin-bottom: 24px; color: #3a3a3c; line-height: 1.6; text-align: left; word-break: keep-all;}
        @media (prefers-color-scheme: dark) { .modal-desc { color: #f5f5f7; } }
        
        .toast-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px);
            padding: 20px 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 3000; display: none; text-align: center; border: 2px solid var(--accent-color);
            animation: toastPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes toastPop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        .toast-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 5px; }
        .toast-msg { font-size: 1rem; color: #3a3a3c; }
        @media (prefers-color-scheme: dark) { .toast-modal { background: rgba(28, 28, 30, 0.9); border-color: #0071e3; color: white; } .toast-msg { color: #d1d1d6; } }

        .rule-list { text-align: left; padding-left: 20px; margin-bottom: 15px; color: inherit; font-size: 0.85rem; }
        .rule-list li { margin-bottom: 8px; }

        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        .skill-container {
            display: flex; justify-content: center; gap: 6px; margin-top: 4px; padding: 6px; background: rgba(0,0,0,0.03); border-radius: 16px;
        }
        .btn-skill {
            flex: 1; padding: 10px 4px; border: 1px solid rgba(0,0,0,0.05); border-radius: 14px; background: white; font-size: 0.7rem; font-weight: 700;
            cursor: pointer; display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 4px; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }
        .btn-skill:active:not(:disabled) { transform: scale(0.95); background: #f2f2f7; }
        .btn-skill:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }
        .skill-icon { font-size: 1rem; }
        .skill-cost { font-size: 0.65rem; color: var(--accent-color); font-weight: 800; margin-left: 2px; }
        .sp-display { font-size: 0.85rem; font-weight: 700; color: #ff3b30; margin-left: 8px; }

        .badge-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 15px; }
        .badge-item { 
            background: rgba(0,0,0,0.03); padding: 10px 5px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; filter: grayscale(1); opacity: 0.5; transition: all 0.3s;
        }
        .badge-item.active { filter: grayscale(0); opacity: 1; background: white; box-shadow: 0 4px 8px rgba(0,0,0,0.05); border: 1px solid rgba(0,113,227,0.1); }
        .badge-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .badge-name { font-size: 0.65rem; font-weight: 700; color: #1d1d1f; text-align: center; }
        @media (prefers-color-scheme: dark) { .badge-item { background: rgba(255,255,255,0.05); } .badge-item.active { background: #2c2c2e; } .badge-name { color: #f5f5f7; } }
        .stat-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(0,0,0,0.05); font-size: 0.9rem; }
        @media (prefers-color-scheme: dark) { .stat-row { border-bottom-color: rgba(255,255,255,0.05); } }
        .stat-label { color: #86868b; font-weight: 500; }
        .stat-value { font-weight: 700; color: var(--accent-color); }

        /* í”„ë¡œí•„ ìŠ¤íƒ€ì¼ */
        .profile-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: white;
            padding: 12px 16px;
            border-radius: 20px;
            border: 1px solid rgba(0,0,0,0.05);
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.03);
        }
        .profile-container:active { transform: scale(0.98); background: #f2f2f7; }
        .profile-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #f2f2f7;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            overflow: hidden;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .profile-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .profile-info { flex: 1; }
        .profile-nickname { font-size: 1rem; font-weight: 800; color: #1d1d1f; margin: 0; }
        .profile-edit-label { font-size: 0.7rem; color: var(--accent-color); font-weight: 600; margin-top: 2px; }
        
        #profileModal .modal-content { padding: 25px; }
        .avatar-upload-box {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #f2f2f7;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 3px solid var(--accent-color);
        }
        .avatar-upload-box img { width: 100%; height: 100%; object-fit: cover; }
        .avatar-upload-overlay {
            position: absolute;
            bottom: 0; width: 100%;
            background: rgba(0,113,227,0.8);
            color: white;
            font-size: 0.6rem;
            padding: 2px 0;
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="app-shell">
    <div id="setupArea">
        <h1 style="margin-bottom: 15px;">ğŸ¥ ëª¨ë°”ì¼ ìœ·ë†€ì´</h1>
        
        <!-- ë‚´ í”„ë¡œí•„ ì˜ì—­ -->
        <div class="profile-container" onclick="openProfileModal()">
            <div class="profile-avatar" id="mainAvatar">ğŸ‘¤</div>
            <div class="profile-info">
                <p class="profile-nickname" id="mainNickname">í”Œë ˆì´ì–´</p>
                <p class="profile-edit-label">ë‚´ í”„ë¡œí•„ ì„¤ì • âš™ï¸</p>
            </div>
        </div>

        <h2 style="margin-top:0; font-weight:800; letter-spacing:-0.03em; font-size: 1.2rem;">ê²Œì„ ì„¤ì •</h2>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <div class="input-group" style="flex: 1; margin: 0; padding: 12px;"><label for="tokenCountInput" style="font-size: 0.8rem;">ë§ ê°œìˆ˜</label><input type="number" id="tokenCountInput" value="2" min="1" max="5" inputmode="numeric"></div>
            <div class="input-group" style="flex: 1; margin: 0; padding: 12px;"><label for="undoCountInput" style="font-size: 0.8rem;">ë¬¼ë¦¬ê¸° íšŸìˆ˜</label><input type="number" id="undoCountInput" value="2" min="0" max="10" inputmode="numeric"></div>
        </div>

        <!-- í”Œë ˆì´ ëª¨ë“œ ëŒ€ë¶„ë¥˜ -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
            <button id="btnPlayAlone" class="btn-secondary" style="flex: 1; margin: 0; background: #f2f2f7; color: #1d1d1f; border: 1px solid rgba(0,0,0,0.1);" onclick="selectTopMode('alone')">ğŸ‘¤ í˜¼ìí•˜ê¸°</button>
            <button id="btnPlayTogether" class="btn-secondary" style="flex: 1; margin: 0; background: #f2f2f7; color: #1d1d1f; border: 1px solid rgba(0,0,0,0.1);" onclick="selectTopMode('together')">ğŸ‘¥ ê°™ì´í•˜ê¸°</button>
        </div>

        <!-- í˜¼ìí•˜ê¸° ì„œë¸Œ ë©”ë‰´ (AI ë‚œì´ë„) -->
        <div id="aloneSubMenu" style="display: none; margin-bottom: 15px; padding: 15px; background: rgba(0,113,227,0.05); border-radius: 18px; border: 1px solid rgba(0,113,227,0.1); text-align: center;">
            <p style="margin: 0 0 10px 0; font-size: 0.85rem; font-weight: 700; color: var(--accent-color);">ğŸ¤– AI ìºë¦­í„° ì„ íƒ</p>
            <button id="aiDifficultyDisplay" style="width: 100%; padding: 12px; border-radius: 12px; border: 1px solid var(--accent-color); background: white; color: var(--accent-color); font-weight: 700; cursor: pointer;" onclick="showAiDifficultyModal()">ğŸ¤– ë³´í†µ âš™ï¸</button>
        </div>

        <!-- ê°™ì´í•˜ê¸° ì„œë¸Œ ë©”ë‰´ (ì˜¤í”„ë¼ì¸/ì˜¨ë¼ì¸ ì„ íƒ) -->
        <div id="togetherSubMenu" style="display: none; margin-bottom: 15px;">
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <button id="btnOffline" class="btn-secondary" style="flex: 1; margin: 0; font-size: 0.8rem; background: #fff; border: 1px solid rgba(0,0,0,0.1);" onclick="selectSubMode('multi')">ğŸ“± ì˜¤í”„ë¼ì¸(ë‹¤ìˆ˜íŒ€)</button>
                <button id="btnOnline" class="btn-secondary" style="flex: 1; margin: 0; font-size: 0.8rem; background: #fff; border: 1px solid rgba(0,0,0,0.1);" onclick="selectSubMode('online')">ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „</button>
            </div>
            
            <!-- ì˜¤í”„ë¼ì¸ íŒ€ ì„¤ì • -->
            <div id="offlineArea" style="display: none;">
                <!-- ì´ ì˜ì—­ì€ ì´ì œ ë¹„ì–´ìˆê±°ë‚˜ ì‚­ì œí•´ë„ ë˜ì§€ë§Œ, êµ¬ì¡° ìœ ì§€ë¥¼ ìœ„í•´ ë‘¡ë‹ˆë‹¤ -->
            </div>

            <!-- ì˜¨ë¼ì¸ ëŒ€ì „ ì„¤ì • -->
            <div id="onlineArea" class="input-group" style="display: none; padding: 12px; background: rgba(0,113,227,0.05); border: 1px solid rgba(0,113,227,0.2);">
                <label style="font-size: 0.8rem; color: var(--accent-color);">ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ ì„¤ì •</label>
                <div style="display: flex; gap: 8px; margin-top: 5px;">
                    <button class="btn-secondary" style="flex: 1; margin: 0; font-size: 0.75rem;" onclick="createOnlineRoom()">ë°© ë§Œë“¤ê¸°</button>
                    <button class="btn-secondary" style="flex: 1; margin: 0; font-size: 0.75rem;" onclick="showJoinRoomPrompt()">ë°© ì°¸ê°€</button>
                </div>
                <div id="roomInfoDisplay" style="margin-top: 8px; font-size: 0.75rem; font-weight: 700; color: var(--accent-color); display: none;"></div>
            </div>

            <!-- ê³µí†µ íŒ€ ë¦¬ìŠ¤íŠ¸ ì˜ì—­ (ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ê³µìš©) -->
            <div id="commonTeamArea" style="margin-top: 15px; background: rgba(0,0,0,0.02); padding: 12px; border-radius: 18px; border: 1px solid rgba(0,0,0,0.05);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <p id="teamListLabel" style="font-weight: 700; color: #86868b; font-size: 0.85rem; margin: 0;">ì°¸ê°€ íŒ€ (ìµœëŒ€ 4íŒ€)</p>
                    <button id="btnAddTeam" class="btn-secondary" style="width:auto; background:rgba(0,0,0,0.05); color:#1d1d1f; border:1px solid rgba(0,0,0,0.1); font-weight:600; margin:0; padding: 6px 12px; font-size: 0.75rem; border-radius: 10px;" onclick="addTeam()">+ íŒ€ ì¶”ê°€</button>
                </div>
                <ul id="teamList" style="list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 0;"></ul>
            </div>
        </div>

        <div class="input-group" style="padding: 12px;"><label style="display: flex; align-items: center; cursor: pointer; font-size: 0.85rem;"><input type="checkbox" id="powerUpMode" style="width: auto; margin-right: 10px;">íŒŒì›Œì—… ëª¨ë“œ (íŠ¹ìˆ˜ ìŠ¤í‚¬)</label></div>
        
        <div style="background: rgba(0,113,227,0.05); padding: 12px; border-radius: 16px; margin-bottom: 15px; border: 1px solid rgba(0,113,227,0.1); cursor: pointer;" onclick="showRules()">
            <p style="margin: 0; font-size: 0.85rem; color: var(--accent-color); font-weight: 700;">ğŸ“– 'ê²Œì„ë°©ë²•'ì„ ë¨¼ì € ì½ì–´ë³´ì„¸ìš”!</p>
            <p style="margin: 4px 0 0 0; font-size: 0.75rem; color: #86868b;">ğŸ•¸ï¸ í•¨ì •ê³¼ âœ¨ ìŠ¤í‚¬ ê·œì¹™ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
        </div>

        <button id="btnStartGame" class="btn-primary" onclick="initGame()" style="display: none;">ê²Œì„ ì‹œì‘ â–¶</button>
        <div style="display:flex; gap:10px; margin-top: 15px;">
            <button class="btn-sound-toggle" style="margin-top:0; flex:1;" onclick="SoundEffect.toggleMute()">ğŸ”Š ì†Œë¦¬ ON</button>
            <button class="btn-info" style="margin-top:0; flex:1; background:var(--accent-color);" onclick="showStats()">ğŸ† ê¸°ë¡ì‹¤</button>
        </div>
        <div style="margin-top: 20px; font-size: 0.7rem; color: #ccc;">ë²„ì „: v1.1.12 (ë‹¤ì‹œí•˜ê¸° ë™ê¸°í™” ë²„ê·¸ ìˆ˜ì •íŒ)</div>
    </div>

    <div class="game-wrapper" id="gameWrapper">
        <h1 style="margin: 5px 0; font-size: 1rem; flex-shrink: 0;">ğŸ¥ ëª¨ë°”ì¼ ìœ·ë†€ì´</h1>
        <div class="board-section">
            <svg id="yutBoard" viewBox="0 0 400 400">
                <path d="M 350 350 L 350 50 L 50 50 L 50 350 L 350 350" class="board-line" />
                <path d="M 50 50 L 350 350" class="board-line" />
                <path d="M 350 50 L 50 350" class="board-line" />
                <g id="boardDots"></g><g id="tokenLayer"></g>
            </svg>
        </div>
        <div class="control-section">
            <div class="status-bar"><span id="turnIndicator" class="current-turn">ì²­íŒ€ ì°¨ë¡€</span><span id="gameInfo" style="font-size:0.8rem; color:#86868b">ë§ 2ê°œ / 2íŒ€</span><span id="spDisplay" class="sp-display" style="display: none;">SP: 3</span></div>
            <div id="skillArea" class="skill-container" style="display: none;">
                <button class="btn-skill" onclick="useSkill('shield')" id="skillShield"><span class="skill-icon">ğŸ›¡ï¸</span><span>ë°©ì–´ë§‰</span><span class="skill-cost">1 SP</span></button>
                <button class="btn-skill" onclick="useSkill('reroll')" id="skillReroll"><span class="skill-icon">ğŸ”„</span><span>ì¬ë„ì „</span><span class="skill-cost">1 SP</span></button>
                <button class="btn-skill" onclick="useSkill('boost')" id="skillBoost"><span class="skill-icon">âš¡</span><span>ë¶€ìŠ¤íŠ¸</span><span class="skill-cost">2 SP</span></button>
            </div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 4px;">
                <div id="availableMoves" style="display:flex; gap:4px;"></div>
                <div class="yut-container" id="yutContainer" style="margin-bottom: 0;"><div class="stick round"></div><div class="stick round"></div><div class="stick round"></div><div class="stick round"></div></div>
            </div>
            <div class="info-text" id="subResult" style="font-weight: 600; color: #1d1d1f; height: 20px;">ë²„íŠ¼ì„ ëˆŒëŸ¬ í˜ì„ ì¡°ì ˆí•˜ì„¸ìš”!</div>
            <div id="gaugeArea"><div class="gauge-wrapper"><div class="zone zone-weak">ì•½í•¨</div><div class="zone zone-safe">ì„±ê³µ</div><div class="zone zone-over">ë‚™ì¥</div><div class="power-bar" id="powerBar"></div></div></div>
            <div id="moveArea" style="display: none;">
                <div id="moveOptions"></div>
            </div>
            <div class="action-btn-row" style="display: flex; gap: 8px; margin-top: 10px; width: 100%; align-items: stretch;">
                <button class="btn-primary" id="actionBtn" onclick="toggleThrow()" style="flex: 0 0 35%; padding: 12px 5px; font-size: 0.75rem;">ë˜ì§€ê¸° (START)</button>
                <button id="btnUndo" class="btn-undo" onclick="undoLastMove()">â†©</button>
            </div>
        </div>
    </div>

    <div id="aiDifficultyModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">ğŸ¤– AI ìºë¦­í„° ì„ íƒ</div>
            <div class="modal-desc" style="text-align: center; margin-bottom: 20px;">ëŒ€ê²°í•  AIì˜ ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</div>
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="btn-primary" onclick="setAiDifficulty('easy')" style="background: #34c759; border-radius: 16px; padding: 15px;">ğŸ· ê¼¬ë§ˆ ë„ì•¼ (ì´ˆë³´)</button>
                <button class="btn-primary" onclick="setAiDifficulty('normal')" style="background: #0071e3; border-radius: 16px; padding: 15px;">ğŸ¶ ì˜ë¦¬í•œ ë—ê°œ (ë³´í†µ)</button>
                <button class="btn-primary" onclick="setAiDifficulty('hard')" style="background: #ff3b30; border-radius: 16px; padding: 15px;">ğŸ‰ ì „ì„¤ì˜ ìœ·ì‹  (ê³ ìˆ˜)</button>
            </div>
            <button class="btn-secondary" style="width: 100%; margin-top: 20px; background: transparent; color: #86868b;" onclick="closeAiModal()">ë‹«ê¸°</button>
        </div>
    </div>

    <!-- ìŠ¹ë¦¬ ëª¨ë‹¬ -->
    <div id="winModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title" id="winTitle">ìŠ¹ë¦¬!</div>
            <div class="modal-desc" id="winDesc">ëª¨ë“  ë§ì´ ì™„ì£¼í–ˆìŠµë‹ˆë‹¤!</div>
            <div id="winModalButtons" style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                <button id="btnRestart" class="btn-primary" onclick="handleRestartClick()">ë‹¤ì‹œ í•˜ê¸°</button>
                <button id="btnExit" class="btn-secondary" onclick="location.reload()" style="margin-top: 5px;">ë©”ë‰´ë¡œ ë‚˜ê°€ê¸°</button>
            </div>
        </div>
    </div>
    <div id="ruleModal" class="modal-overlay">
        <div class="modal-content" style="text-align: left; max-height: 80vh; overflow-y: auto;">
            <div class="modal-title" style="text-align: center;">ğŸ“œ ê²Œì„ ë°©ë²•</div>
            <div class="modal-desc">
                <div style="margin-bottom: 20px;">
                    <p style="color: var(--accent-color); font-weight: bold; margin-bottom: 10px; border-bottom: 2px solid #eee; padding-bottom: 5px;">ğŸ•¹ï¸ ê¸°ë³¸ ê·œì¹™</p>
                    <ul class="rule-list">
                        <li><strong>ë˜ì§€ê¸°:</strong> íŒŒì›Œ ê²Œì´ì§€ì˜ ì„±ê³µ êµ¬ê°„ì— ë§ì¶° ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</li>
                        <li><strong>ë³´ë„ˆìŠ¤:</strong> 'ìœ·', 'ëª¨' ë˜ëŠ” ìƒëŒ€ ë§ì„ ì¡ìœ¼ë©´ í•œ ë²ˆ ë” ë˜ì§‘ë‹ˆë‹¤.</li>
                        <li><strong>ì—…ê¸°:</strong> ìê¸° íŒ€ì˜ ë§ì´ ê°™ì€ ì¹¸ì— ìˆìœ¼ë©´ í•¨ê»˜ ì´ë™í•©ë‹ˆë‹¤.</li>
                        <li><strong>ì§€ë¦„ê¸¸:</strong> ëª¨ì„œë¦¬ë‚˜ ì¤‘ì•™ ì¹¸ì— ë©ˆì¶”ë©´ ì§€ë¦„ê¸¸ë¡œ ì§„ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                        <li><strong>ğŸ•¸ï¸ í•¨ì •:</strong> íŒ ìœ„ì— ë¬´ì‘ìœ„ë¡œ ì„¤ì¹˜ëœ 3ê°œì˜ í•¨ì •ì„ ì£¼ì˜í•˜ì„¸ìš”! í•¨ì •ì— ë©ˆì¶”ë©´ ì¦‰ì‹œ ì¶œë°œì§€ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px;">
                    <p style="color: #ff9500; font-weight: bold; margin-bottom: 10px; border-bottom: 2px solid #eee; padding-bottom: 5px;">ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ ë°©ë²•</p>
                    <ul class="rule-list">
                        <li><strong>ë°© ë§Œë“¤ê¸°:</strong> 'ë°© ë§Œë“¤ê¸°'ë¥¼ ëˆŒëŸ¬ 6ìë¦¬ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</li>
                        <li><strong>ì´ˆëŒ€í•˜ê¸°:</strong> 'ì½”ë“œ ë³µì‚¬' ë˜ëŠ” 'ë§í¬ ë³µì‚¬' í›„ ì¹´í†¡/ë¬¸ìë¡œ ì¹œêµ¬ì—ê²Œ ë³´ëƒ…ë‹ˆë‹¤.</li>
                        <li><strong>ì°¸ê°€í•˜ê¸°:</strong> ê³µìœ ë°›ì€ ë§í¬ë¥¼ í´ë¦­í•˜ê±°ë‚˜, 'ë°© ì°¸ê°€'ë¥¼ ëˆŒëŸ¬ 6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.</li>
                        <li><strong>ì‹œì‘í•˜ê¸°:</strong> ì¹œêµ¬ê°€ ì ‘ì†í•˜ì—¬ ëª…ë‹¨ì— ë³´ì´ë©´ 'ê²Œì„ ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.</li>
                    </ul>
                </div>

                <div style="margin-bottom: 10px;">
                    <p style="color: var(--accent-color); font-weight: bold; margin-bottom: 10px; border-bottom: 2px solid #eee; padding-bottom: 5px;">âœ¨ íŒŒì›Œì—… ëª¨ë“œ (SP ìŠ¤í‚¬)</p>
                    <ul class="rule-list">
                        <li style="font-size: 0.8rem; margin-bottom: 5px; list-style: none; margin-left: -15px;">* ìì‹ ì˜ ì°¨ë¡€ì— SPë¥¼ ì†Œëª¨í•˜ì—¬ ìŠ¤í‚¬ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.</li>
                        <li><strong>SP ì¶©ì „:</strong> ìƒëŒ€ ë§ì„ ì¡ì„ ë•Œë§ˆë‹¤ 1 SPê°€ ì¶©ì „ë©ë‹ˆë‹¤ (ìµœëŒ€ 5).</li>
                        <li><strong>ğŸ›¡ï¸ ë°©ì–´ë§‰ (1 SP):</strong> ìƒëŒ€ì˜ ì¡ê¸°ë¥¼ 1íšŒ ë°©ì–´í•©ë‹ˆë‹¤.</li>
                        <li><strong>ğŸ”„ ì¬ë„ì „ (1 SP):</strong> íŒ¨ë¥¼ ì·¨ì†Œí•˜ê³  ë‹¤ì‹œ ë˜ì§‘ë‹ˆë‹¤.</li>
                        <li><strong>âš¡ ë¶€ìŠ¤íŠ¸ (2 SP):</strong> ì¦‰ì‹œ 2ì¹¸ ì „ì§„í•˜ë©°, ì´ë•Œ ìƒëŒ€ë¥¼ ì¡ì•„ë„ ë³´ë„ˆìŠ¤ ê¸°íšŒë¥¼ ì–»ìŠµë‹ˆë‹¤.</li>
                    </ul>
                </div>
            </div>
            <button class="btn-secondary" style="width: 100%; background:#8e8e93; margin-top: 10px;" onclick="closeRules()">ë‹«ê¸°</button>
        </div>
    </div>
    <div id="statsModal" class="modal-overlay"><div class="modal-content"><div class="modal-title">ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</div><div style="margin-bottom: 20px;"><div class="stat-row"><span class="stat-label">ì´ í”Œë ˆì´</span><span class="stat-value" id="statTotalGames">0</span></div><div class="stat-row"><span class="stat-label">ìŠ¹ë¦¬ íšŸìˆ˜</span><span class="stat-value" id="statWins">0</span></div><div class="stat-row"><span class="stat-label">ìŠ¹ë¥ </span><span class="stat-value" id="statWinRate">0%</span></div><div class="stat-row"><span class="stat-label">ìµœë‹¤ ì¡ê¸° (í•œ ê²Œì„)</span><span class="stat-value" id="statMaxCaptures">0</span></div></div><div style="font-weight: 800; font-size: 1rem; text-align: left; margin-top: 20px; color: var(--primary-color);">ğŸ… ì—…ì  ë°°ì§€</div><div class="badge-grid" id="badgeGrid"><div class="badge-item" id="badge_FIRST_WIN"><div class="badge-icon">ğŸ¥‡</div><div class="badge-name">ì²« ìŠ¹ë¦¬</div></div><div class="badge-item" id="badge_YUT_GOD"><div class="badge-icon">âš¡</div><div class="badge-name">ìœ·ì‹ ìœ·ì™•</div></div><div class="badge-item" id="badge_CATCH_MASTER"><div class="badge-icon">ğŸ¯</div><div class="badge-name">ì‚¬ëƒ¥ê¾¼</div></div><div class="badge-item" id="badge_STACK_KING"><div class="badge-icon">ğŸ°</div><div class="badge-name">ì² ë²½ê¸°ì‚¬</div></div><div class="badge-item" id="badge_BOOST_CATCH"><div class="badge-icon">ğŸš€</div><div class="badge-name">ê³ ì†ë„ë¡œ</div></div><div class="badge-item" id="badge_SHIELD_SUCCESS"><div class="badge-icon">ğŸ›¡ï¸</div><div class="badge-name">ë°©ì–´ì„±ê³µ</div></div></div><button class="btn-primary" style="margin-top: 30px; background: #8e8e93;" onclick="closeStats()">ë‹«ê¸°</button></div></div>
    
    <!-- í”„ë¡œí•„ ì„¤ì • ëª¨ë‹¬ -->
    <div id="profileModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">í”„ë¡œí•„ ì„¤ì •</div>
            <div class="avatar-upload-box" onclick="document.getElementById('avatarInput').click()">
                <div id="editAvatar">ğŸ‘¤</div>
                <div class="avatar-upload-overlay">ë³€ê²½</div>
            </div>
            <input type="file" id="avatarInput" accept="image/*" style="display: none;" onchange="handleAvatarUpload(event)">
            
            <div class="input-group" style="margin-bottom: 20px;">
                <label for="nicknameInput" style="font-size: 0.85rem; color: #86868b;">ë³„ëª… (ë‹‰ë„¤ì„)</label>
                <input type="text" id="nicknameInput" placeholder="ë³„ëª…ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
            </div>
            
            <div style="display: flex; gap: 10px; width: 100%;">
                <button class="btn-primary" onclick="saveProfile()" style="flex: 1; margin: 0;">ì €ì¥í•˜ê¸°</button>
                <button class="btn-secondary" onclick="closeProfileModal()" style="flex: 1; margin: 0; background: #8e8e93;">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>
    
    <div id="toastModal" class="toast-modal">
        <div id="toastTitle" class="toast-title"></div>
        <div id="toastMsg" class="toast-msg"></div>
    </div>

    <canvas id="confettiCanvas" style="position:fixed; top:0; left:0; pointer-events:none; z-index:2000; display:none;"></canvas>
    </div>

    <script>
        function optimizeLayout() {
            // ì‹¤ì œ ê¸°ê¸°ì˜ ê°€ìš© ë†’ì´ë¥¼ ë” ë³´ìˆ˜ì ìœ¼ë¡œ ê³„ì‚°
            const vh = window.innerHeight;
            const vw = window.innerWidth;
            
            // í˜„ì¬ í™œì„±í™”ëœ í™”ë©´ì˜ ì œëª© ìš”ì†Œë¥¼ ì°¾ìŒ
            const activeTitle = (gameState.step === 'SETUP') ? 
                document.querySelector('#setupArea h1') : 
                document.querySelector('#gameWrapper h1');
            
            const control = document.querySelector('.control-section');
            
            // ì œëª©, ì»¨íŠ¸ë¡¤ëŸ¬, ê·¸ë¦¬ê³  ìƒí•˜ë‹¨ UI ì—¬ë°±ì„ í•©ì³ì„œ ê³„ì‚°
            let occupiedH = (activeTitle ? activeTitle.offsetHeight : 0) + 
                            (control && gameState.step !== 'SETUP' ? control.offsetHeight : 0) + 20;
            
            const availableH = vh - occupiedH;
            // ê°€ë¡œ ë„ˆë¹„ë¥¼ ìµœëŒ€í•œ í™œìš©í•˜ë©´ì„œ ì„¸ë¡œ ê°€ìš© ë†’ì´ì— ë§ì¶¤
            const boardSize = Math.min(vw * 0.98, availableH * 0.98, 550);
            document.documentElement.style.setProperty('--board-size', `${boardSize}px`);
        }
        window.addEventListener('resize', optimizeLayout);
        window.addEventListener('load', optimizeLayout);

        const GameStats = {
            data: { totalGames: 0, wins: 0, maxCaptures: 0, achievements: [] },
            currentSession: { captures: 0, yutMoCount: 0, maxStacked: 1, usedShield: false, usedBoost: false },
            init: function() { const saved = localStorage.getItem('yutnori_stats'); if (saved) this.data = { ...this.data, ...JSON.parse(saved) }; },
            save: function() { localStorage.setItem('yutnori_stats', JSON.stringify(this.data)); },
            unlockAchievement: function(id) { if (!this.data.achievements.includes(id)) { this.data.achievements.push(id); this.save(); if (gameState.step !== 'SETUP') showMessage(`ğŸ… ì—…ì  ë‹¬ì„±: ${this.getAchievementName(id)}!`, "#ff9500"); return true; } return false; },
            getAchievementName: function(id) { const names = { 'FIRST_WIN': 'ì²« ìŠ¹ë¦¬', 'YUT_GOD': 'ìœ·ì‹ ìœ·ì™•', 'CATCH_MASTER': 'ì‚¬ëƒ¥ê¾¼', 'STACK_KING': 'ì² ë²½ê¸°ì‚¬', 'BOOST_CATCH': 'ê³ ì†ë„ë¡œ', 'SHIELD_SUCCESS': 'ë°©ì–´ì„±ê³µ' }; return names[id] || id; },
            recordGameEnd: function(isWin) { this.data.totalGames++; if (isWin) { this.data.wins++; this.unlockAchievement('FIRST_WIN'); } if (this.currentSession.captures > this.data.maxCaptures) this.data.maxCaptures = this.currentSession.captures; if (this.currentSession.yutMoCount >= 5) this.unlockAchievement('YUT_GOD'); if (this.currentSession.captures >= 5) this.unlockAchievement('CATCH_MASTER'); if (this.currentSession.maxStacked >= 3) this.unlockAchievement('STACK_KING'); this.save(); },
            resetSession: function() { this.currentSession = { captures: 0, yutMoCount: 0, maxStacked: 1, usedShield: false, usedBoost: false }; }
        };
        GameStats.init();

        const SoundEffect = {
            ctx: null, isMuted: false,
            init: function() { if (!this.ctx) { const AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
            toggleMute: function() { this.isMuted = !this.isMuted; const btn = document.querySelector('.btn-sound-toggle'); if(btn) btn.innerText = this.isMuted ? "ğŸ”‡ ì†Œë¦¬ OFF" : "ğŸ”Š ì†Œë¦¬ ON"; },
            playTone: function(freq, type, duration, startTime = 0) { if (this.isMuted || !this.ctx) return; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = type; osc.frequency.value = freq; osc.connect(gain); gain.connect(this.ctx.destination); const now = this.ctx.currentTime + startTime; osc.start(now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + duration); osc.stop(now + duration); },
            playClick: function() { this.playTone(600, 'sine', 0.1); },
            playStartGauge: function() { if (this.isMuted || !this.ctx) return; const now = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(600, now + 0.3); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(now); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0.001, now + 0.3); osc.stop(now + 0.3); },
            playFail: function() { this.playTone(400, 'sawtooth', 0.2, 0); this.playTone(300, 'sawtooth', 0.4, 0.2); },
            playYutThrow: function() { this.playTone(523.25, 'sine', 0.1, 0); this.playTone(659.25, 'sine', 0.1, 0.1); this.playTone(783.99, 'sine', 0.2, 0.2); },
            playGoodThrow: function() { this.playTone(523.25, 'square', 0.1, 0); this.playTone(783.99, 'square', 0.1, 0.1); this.playTone(1046.50, 'square', 0.3, 0.2); },
            playMove: function() { this.playTone(800, 'sine', 0.05); },
            playCatch: function() { if (this.isMuted || !this.ctx) return; const now = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(now); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0.001, now + 0.2); osc.stop(now + 0.2); },
            playWin: function() { const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; const times = [0, 0.2, 0.4, 0.6, 0.8, 1.0]; notes.forEach((freq, i) => this.playTone(freq, 'triangle', 0.3, times[i])); }
        };

        const TEAM_COLORS = [ { name: "ì²­íŒ€", code: "#0071e3" }, { name: "í™íŒ€", code: "#ff3b30" }, { name: "ì´ˆë¡íŒ€", code: "#34c759" }, { name: "ë…¸ë‘íŒ€", code: "#ffcc00" } ];
        let teams = [];
        let gameState = { currentTeamIdx: 0, step: 'SETUP', moveQueue: [], selectedMoveId: null, maxUndos: 2, traps: [], selectedSkillType: null };
        let historyState = null;
        let tokensPerTeam = 2;
        let isPowerUpMode = false;
        let gameMode = 'multi'; // multi, ai, online
        let topMode = 'together'; // alone, together
        let aiDifficulty = 'normal';
        let aiTimeoutId = null;
        const aiActionDelay = 2500;

        // ì˜¨ë¼ì¸ ëŒ€ì „ ê´€ë ¨ ë³€ìˆ˜ (PeerJS ê¸°ë°˜)
        let peer = null;
        let connections = []; // í˜¸ìŠ¤íŠ¸ì¼ ê²½ìš° ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì €ì¥
        let conn = null; // í´ë¼ì´ì–¸íŠ¸ì¼ ê²½ìš° í˜¸ìŠ¤íŠ¸ì™€ì˜ ì—°ê²° ì €ì¥
        let isHost = false;
        let isOnlineMode = false;
        let onlineRoomId = null;
        let myTeamIdx = null; 
        let onlinePlayerName = "í”Œë ˆì´ì–´";
        let isConnecting = false;

        function selectTopMode(mode) {
            SoundEffect.playClick();
            topMode = mode;
            
            const btnAlone = document.getElementById('btnPlayAlone');
            const btnTogether = document.getElementById('btnPlayTogether');
            const aloneSub = document.getElementById('aloneSubMenu');
            const togetherSub = document.getElementById('togetherSubMenu');
            const btnStart = document.getElementById('btnStartGame');

            if (mode === 'alone') {
                btnAlone.style.background = 'var(--accent-color)';
                btnAlone.style.color = 'white';
                btnTogether.style.background = '#f2f2f7';
                btnTogether.style.color = '#1d1d1f';
                
                aloneSub.style.display = 'block';
                togetherSub.style.display = 'none';
                btnStart.style.display = 'block';
                gameMode = 'ai';
                
                // íŒ€ ì´ˆê¸°í™” (2íŒ€ ê³ ì •)
                if (teams.length > 2) teams = teams.slice(0, 2);
                renderTeamSetup();
                showAiDifficultyModal();
            } else {
                btnTogether.style.background = 'var(--accent-color)';
                btnTogether.style.color = 'white';
                btnAlone.style.background = '#f2f2f7';
                btnAlone.style.color = '#1d1d1f';
                
                togetherSub.style.display = 'block';
                aloneSub.style.display = 'none';
                btnStart.style.display = 'none'; // ì„œë¸Œ ëª¨ë“œ(ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸)ë¥¼ ê³¨ë¼ì•¼ ì‹œì‘ ë²„íŠ¼ ë³´ì„
            }
        }

        function selectSubMode(mode) {
            SoundEffect.playClick();
            gameMode = mode;
            
            const btnOffline = document.getElementById('btnOffline');
            const btnOnline = document.getElementById('btnOnline');
            const offlineArea = document.getElementById('offlineArea');
            const onlineArea = document.getElementById('onlineArea');
            const btnStart = document.getElementById('btnStartGame');
            const btnAdd = document.getElementById('btnAddTeam');
            const teamArea = document.getElementById('commonTeamArea');
            const teamLabel = document.getElementById('teamListLabel');
            const teamList = document.getElementById('teamList');

            if (mode === 'multi') {
                btnOffline.style.background = 'var(--accent-color)';
                btnOffline.style.color = 'white';
                btnOnline.style.background = '#fff';
                btnOnline.style.color = '#1d1d1f';
                
                offlineArea.style.display = 'block';
                onlineArea.style.display = 'none';
                teamArea.style.display = 'block';
                teamLabel.innerText = "ì°¸ê°€ íŒ€ (ìµœëŒ€ 4íŒ€)";
                btnAdd.style.display = 'block';
                btnAdd.disabled = false;
                btnAdd.style.opacity = "1";
                
                // ì˜¤í”„ë¼ì¸ ëª¨ë“œì¼ ë•Œ ê¸°ë³¸ íŒ€ ë³µêµ¬ (ë¹„ì–´ìˆë‹¤ë©´)
                if (teams.length === 0) {
                    addTeamData(0);
                    addTeamData(1);
                }
                renderTeamSetup();
            } else {
                btnOnline.style.background = 'var(--accent-color)';
                btnOnline.style.color = 'white';
                btnOffline.style.background = '#fff';
                btnOffline.style.color = '#1d1d1f';
                
                onlineArea.style.display = 'block';
                offlineArea.style.display = 'none';
                teamArea.style.display = 'block';
                teamLabel.innerText = "í˜„ì¬ ì ‘ì† ì¸ì›";
                btnAdd.style.display = 'none';
                btnAdd.disabled = true;
                btnAdd.style.opacity = "0.4";
                
                // ì˜¨ë¼ì¸ ëŒ€ì „ ì§„ì… ì‹œ ì˜¤í”„ë¼ì¸ íŒ€ ëª…ë‹¨ ì‚­ì œ ë° ëŒ€ê¸° ìƒíƒœ í‘œì‹œ
                teams = [];
                teamList.innerHTML = `<li style="padding:15px; color:#86868b; font-size:0.8rem; text-align:center; width:100%;">ë°© ë§Œë“¤ê¸° ë˜ëŠ” ì°¸ê°€ í›„ ëŒ€ê¸°í•˜ì„¸ìš”...</li>`;
                
                initP2P();
            }
            btnStart.style.display = 'block';
        }

        // í”„ë¡œí•„ ê´€ë¦¬ ê°ì²´
        const ProfileManager = {
            storageKey: 'yutnori_profile',
            data: { nickname: 'í”Œë ˆì´ì–´', avatar: null },
            load() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        this.data = JSON.parse(saved);
                        this.updateUI();
                    } catch(e) { console.error("Profile load error", e); }
                }
            },
            save(nickname, avatar) {
                this.data = { nickname, avatar };
                localStorage.setItem(this.storageKey, JSON.stringify(this.data));
                this.updateUI();
            },
            updateUI() {
                document.getElementById('mainNickname').innerText = this.data.nickname;
                const avatarHTML = this.data.avatar ? `<img src="${this.data.avatar}">` : 'ğŸ‘¤';
                document.getElementById('mainAvatar').innerHTML = avatarHTML;
                document.getElementById('editAvatar').innerHTML = avatarHTML;
                document.getElementById('nicknameInput').value = this.data.nickname;
                
                // ì˜¨ë¼ì¸ ëŒ€ì „ ë‹‰ë„¤ì„ í•„ë“œ ìë™ ì±„ìš°ê¸°
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.value = this.data.nickname;
            }
        };

        function openProfileModal() {
            SoundEffect.playClick();
            document.getElementById('profileModal').style.display = 'flex';
        }

        function closeProfileModal() {
            SoundEffect.playClick();
            document.getElementById('profileModal').style.display = 'none';
        }

        function handleAvatarUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // íŒŒì¼ í¬ê¸° ì œí•œ (ì•½ 500KB)
            if (file.size > 512000) {
                alert("ì´ë¯¸ì§€ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. (500KB ì´í•˜ ê¶Œì¥)");
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const base64 = e.target.result;
                document.getElementById('editAvatar').innerHTML = `<img src="${base64}">`;
            };
            reader.readAsDataURL(file);
        }

        function saveProfile() {
            const nick = document.getElementById('nicknameInput').value.trim();
            if (!nick) { alert("ë³„ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
            
            const avatarImg = document.querySelector('#editAvatar img');
            const avatarBase64 = avatarImg ? avatarImg.src : null;
            
            ProfileManager.save(nick, avatarBase64);
            closeProfileModal();
            showToast("í”„ë¡œí•„ ì €ì¥", "ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }

        function initSetup() { 
            ProfileManager.load(); // í”„ë¡œí•„ ë¡œë“œ
            addTeamData(0); 
            addTeamData(1); 
            renderTeamSetup(); 
            // ê¸°ë³¸ê°’ìœ¼ë¡œ 'ê°™ì´í•˜ê¸°' -> 'ì˜¤í”„ë¼ì¸' ì„ íƒ ìƒíƒœë¡œ ì‹œì‘
            selectTopMode('together');
            selectSubMode('multi');
        }
        function renderTeamSetup() {
            const teamList = document.getElementById('teamList');
            teamList.innerHTML = "";
            teams.forEach((t, i) => { 
                const avatarHTML = t.avatar ? `<img src="${t.avatar}" style="width:20px; height:20px; border-radius:50%; margin-right:6px; object-fit:cover;">` : `<span style="margin-right:6px;">ğŸ‘¤</span>`;
                teamList.innerHTML += `<li style="padding:6px 12px; color:${t.color}; font-weight:800; display:flex; align-items:center; background:white; border-radius:12px; border:1px solid ${t.color}22; box-shadow:0 2px 4px rgba(0,0,0,0.03); font-size:0.85rem;">
                    ${avatarHTML}
                    <span>${t.name}</span>
                    ${i > 1 ? `<button onclick="removeTeam(${i})" style="margin-left:6px; cursor:pointer; background:none; color:#ff3b30; border:none; padding:0; font-weight:900; font-size:1.1rem; line-height:1;">Ã—</button>` : ''}
                </li>`; 
            });
            const btnAdd = document.getElementById('btnAddTeam');
            const isAddDisabled = (teams.length >= 4 || gameMode === 'ai' || gameMode === 'online');
            btnAdd.disabled = isAddDisabled;
            btnAdd.style.opacity = isAddDisabled ? "0.4" : "1";
            btnAdd.style.display = teams.length >= 4 ? 'none' : 'block';
        }
        function addTeamData(colorIdx) { if (teams.length >= 4) return; const c = TEAM_COLORS[colorIdx]; teams.push({ id: teams.length, name: c.name, color: c.code, tokens: [], remainingUndos: 2, isAi: false, sp: 3 }); }
        function addTeam() { SoundEffect.playClick(); if (teams.length >= 4) return alert("ìµœëŒ€ 4íŒ€"); addTeamData(teams.length); renderTeamSetup(); }
        function removeTeam(idx) { SoundEffect.playClick(); teams.splice(idx, 1); teams.forEach((t, i) => { t.id = i; t.name = TEAM_COLORS[i%4].name; t.color = TEAM_COLORS[i%4].code; }); renderTeamSetup(); }

        function initP2P(customId, callback) {
            // ì»¤ìŠ¤í…€ ID(ë°©ì¥ ì½”ë“œ)ê°€ ì œê³µë˜ì—ˆëŠ”ë° í˜„ì¬ Peerì™€ IDê°€ ë‹¤ë¥´ë‹¤ë©´ ìƒˆë¡œ ìƒì„±í•´ì•¼ í•¨
            if (customId && peer && !peer.destroyed && peer.id !== customId) {
                peer.destroy();
                peer = null;
            }

            if (isConnecting && !customId) return; 
            isConnecting = true;

            if (peer && !peer.destroyed) {
                if (peer.open) {
                    isConnecting = false;
                    if (callback) callback();
                } else {
                    peer.once('open', () => {
                        isConnecting = false;
                        if (callback) callback();
                    });
                }
                return;
            }
            
            peer = customId ? new Peer(customId) : new Peer();
            
            peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                isConnecting = false;
                if (callback) callback();
            });

            peer.on('error', (err) => {
                isConnecting = false;
                console.error('PeerJS Error:', err);
                if (err.type === 'peer-disconnected') showToast("ì—°ê²° ëŠê¹€", "ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ì„¸ìš”.");
                else if (err.type === 'unavailable-id') {
                    if (isHost) createOnlineRoom();
                    else showToast("ì˜¤ë¥˜", "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë°© ì½”ë“œì…ë‹ˆë‹¤.");
                }
                else if (err.type === 'peer-not-found') showToast("ì˜¤ë¥˜", "ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                else showToast("ì—°ê²° ì‹¤íŒ¨", "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
            });

            peer.on('connection', (newConn) => {
                if (!isHost) {
                    newConn.close();
                    return;
                }
                setupConnection(newConn);
            });
        }

        function setupConnection(c) {
            const onOpen = () => {
                if (!connections.find(item => item.peer === c.peer)) {
                    connections.push(c);
                }
                console.log("Connected to guest: " + c.peer);
            };

            if (c.open) onOpen();
            else c.on('open', onOpen);

            c.on('data', (data) => {
                if (data.type === 'join') {
                    if (teams.length >= 4) {
                        c.send({ type: 'error', msg: 'ë°©ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.' });
                        return;
                    }
                    const teamIdx = teams.length;
                    const color = TEAM_COLORS[teamIdx % 4];
                    // ì ‘ì†í•œ í´ë¼ì´ì–¸íŠ¸ì˜ peerIdì™€ avatar ì €ì¥
                    teams.push({ id: teamIdx, name: data.playerName, color: color.code, tokens: [], remainingUndos: 2, isAi: false, sp: 3, peerId: c.peer, avatar: data.avatar });
                    
                    c.send({
                        type: 'playerList',
                        teams: teams.map(t => ({ name: t.name, color: t.color, avatar: t.avatar })),
                        myTeamIdx: teamIdx
                    });

                    broadcast({
                        type: 'playerList',
                        teams: teams.map(t => ({ name: t.name, color: t.color, avatar: t.avatar }))
                    });
                    
                    renderTeamSetup();
                    showToast("í”Œë ˆì´ì–´ ì…ì¥", `${data.playerName}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`);
                } else if (data.type === 'action') {
                    handleRemoteAction(data.action);
                    if (isHost) {
                        connections.forEach(connItem => {
                            if (connItem.peer !== c.peer && connItem.open) {
                                connItem.send({ type: 'action', action: data.action });
                            }
                        });
                    }
                } else if (data.type === 'restartRequest') {
                    // í˜¸ìŠ¤íŠ¸ê°€ ìš”ì²­ì„ ë°›ìœ¼ë©´ ìš”ì²­í•œ í´ë¼ì´ì–¸íŠ¸ë¥¼ 'ìˆ˜ë½' ìƒíƒœë¡œ ê¸°ë¡
                    if (data.peerId) {
                        restartVotes[data.peerId] = true;
                    }
                    showRestartConfirm();
                    connections.forEach(connItem => {
                        if (connItem.peer !== c.peer && connItem.open) {
                            connItem.send({ type: 'restartRequest', peerId: data.peerId });
                        }
                    });
                    // í˜¸ìŠ¤íŠ¸ê°€ ì´ë¯¸ ìˆ˜ë½ ìƒíƒœë¼ë©´ íˆ¬í‘œ í™•ì¸
                    if (restartVotes[peer.id]) {
                        handleHostRestartVote(peer.id, true);
                    }
                } else if (data.type === 'restartResponse') {
                    handleHostRestartVote(data.peerId, data.accepted);
                    connections.forEach(connItem => {
                        if (connItem.peer !== c.peer && connItem.open) {
                            connItem.send({ type: 'restartResponse', accepted: data.accepted, peerId: data.peerId });
                        }
                    });
                }
            });

            c.on('close', () => {
                connections = connections.filter(item => item.peer !== c.peer);
                showToast("ì—°ê²° ì¢…ë£Œ", "í”Œë ˆì´ì–´ í•œ ëª…ì´ ë‚˜ê°”ìŠµë‹ˆë‹¤.");
            });
        }

        function generateRoomId() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = '';
            for (let i = 0; i < 6; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }

        function createOnlineRoom() {
            // ì´ë¯¸ ë°©ì¥ ëª¨ë“œì´ê³  IDê°€ ìƒì„±ë˜ì—ˆë‹¤ë©´ ì¤‘ë³µ ìƒì„± ë°©ì§€
            if (isHost && onlineRoomId && document.getElementById('roomInfoDisplay').style.display === 'block') {
                return;
            }

            onlinePlayerName = ProfileManager.data.nickname;
            isHost = true;
            
            // 6ìë¦¬ ì§§ì€ ì½”ë“œ ìƒì„±
            const shortId = generateRoomId();
            
            showToast("ë°© ìƒì„± ì¤‘...", shortId);
            
            // ë°©ì¥ ìƒì„± ì „ ê¸°ì¡´ Peerê°€ ìˆë‹¤ë©´ ì •ë¦¬
            if (peer && !peer.destroyed) {
                peer.destroy();
                peer = null;
            }

            initP2P(shortId, () => {
                onlineRoomId = peer.id; 
                myTeamIdx = 0;
                // peerIdì™€ avatarë¥¼ íŒ€ ì •ë³´ì— ì¶”ê°€ (ë°©ì¥ ìì‹ )
                teams = [{ id: 0, name: onlinePlayerName, color: TEAM_COLORS[0].code, tokens: [], remainingUndos: 2, isAi: false, sp: 3, peerId: peer.id, avatar: ProfileManager.data.avatar }];
                renderTeamSetup();

                const display = document.getElementById('roomInfoDisplay');
                display.style.display = 'block';
                display.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:10px; align-items:center; padding:5px 0;">
                        <div style="font-size:1.3rem; font-weight:900; color:var(--accent-color); background:#0071e311; padding:10px 20px; border-radius:12px; border:2px solid var(--accent-color); letter-spacing:5px; font-family:monospace;">${onlineRoomId}</div>
                        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; width:100%;">
                            <button onclick="copyRoomCode()" style="background:#3a2d28; color:white; border:none; padding:12px; border-radius:12px; font-size:0.85rem; font-weight:700; cursor:pointer;">ğŸ”¢ ì½”ë“œ ë³µì‚¬</button>
                            <button onclick="copyInviteLink()" style="background:var(--accent-color); color:white; border:none; padding:12px; border-radius:12px; font-size:0.85rem; font-weight:700; cursor:pointer;">ğŸ”— ë§í¬ ë³µì‚¬</button>
                        </div>
                    </div>
                `;
                showToast("ë°© ìƒì„± ì™„ë£Œ", onlineRoomId);
            });
        }

        function copyRoomCode() {
            if (!onlineRoomId) return;
            navigator.clipboard.writeText(onlineRoomId).then(() => showToast("ë³µì‚¬ ì™„ë£Œ", onlineRoomId));
        }

        function copyInviteLink() {
            if (!onlineRoomId) return;
            const url = `${window.location.origin}${window.location.pathname}?room=${onlineRoomId}`;
            navigator.clipboard.writeText(url).then(() => showToast("ë§í¬ ë³µì‚¬ ì™„ë£Œ", "ì¹´í†¡ì— ì „ë‹¬í•˜ì„¸ìš”!"));
        }

        function checkUrlParams() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                // ì˜¨ë¼ì¸ ëª¨ë“œë¡œ ê°•ì œ ì„¤ì •
                selectTopMode('together');
                selectSubMode('online');
                setTimeout(() => joinOnlineRoom(roomCode.trim().toUpperCase()), 1200);
            }
        }
        window.addEventListener('load', checkUrlParams);

        function showJoinRoomPrompt() {
            if (isConnecting) return;
            const code = prompt("ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš” (6ìë¦¬):");
            if (code) joinOnlineRoom(code.trim().toUpperCase());
        }

        function joinOnlineRoom(code) {
            if (isConnecting) {
                showToast("ì—°ê²° ì¤€ë¹„ ì¤‘", "ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...");
            }
            
            onlinePlayerName = ProfileManager.data.nickname;
            isHost = false;
            onlineRoomId = code;

            initP2P(null, () => {
                showToast("ë°© ì°¾ëŠ” ì¤‘...", onlineRoomId);
                const newConn = peer.connect(onlineRoomId);
                
                newConn.on('open', () => {
                    conn = newConn; 
                    showToast("ì—°ê²° ì„±ê³µ", "ë°ì´í„° ë™ê¸°í™” ì¤‘...");
                    newConn.send({ type: 'join', playerName: onlinePlayerName, avatar: ProfileManager.data.avatar });
                });

                newConn.on('data', (data) => {
                    if (data.type === 'playerList') {
                        // ê¸°ì¡´ peerId ë“±ì˜ ì •ë³´ ë³´ì¡´ì„ ìœ„í•´ ì—…ë°ì´íŠ¸ ë¡œì§ ì •êµí™”
                        const newTeams = [];
                        data.teams.forEach((t, i) => {
                            const existingTeam = teams.find(et => et.name === t.name);
                            if (existingTeam) {
                                newTeams.push({ ...existingTeam, id: i, color: t.color, avatar: t.avatar });
                            } else {
                                newTeams.push({ id: i, name: t.name, color: t.color, tokens: [], remainingUndos: 2, isAi: false, sp: 3, peerId: (t.name === onlinePlayerName ? peer.id : null), avatar: t.avatar });
                            }
                        });
                        teams = newTeams;
                        if (data.myTeamIdx !== undefined) myTeamIdx = data.myTeamIdx;
                        
                        if (data.restart) {
                            showToast("íŒ€ ì¬êµ¬ì„±", "ë‚˜ê°„ í”Œë ˆì´ì–´ë¥¼ ì œì™¸í•˜ê³  ê²Œì„ì„ ë‹¤ì‹œ ì¤€ë¹„í•©ë‹ˆë‹¤.");
                        }
                        renderTeamSetup();
                    } else if (data.type === 'error') {
                        alert(data.msg);
                        location.reload();
                    } else if (data.type === 'gameStarted') {
                        initGame(data.initialState);
                    } else if (data.type === 'action') {
                        handleRemoteAction(data.action);
                    } else if (data.type === 'sync') {
                        applySyncState(data);
                    } else if (data.type === 'restartRequest') {
                        showRestartConfirm();
                    } else if (data.type === 'restartResponse') {
                        if (data.accepted) {
                            showToast("ìˆ˜ë½ ì•Œë¦¼", "í”Œë ˆì´ì–´ê°€ í•œ íŒ ë” í•˜ê¸°ë¥¼ ìˆ˜ë½í–ˆìŠµë‹ˆë‹¤.");
                        } else {
                            showToast("í”Œë ˆì´ì–´ ë‚˜ê°", "í”Œë ˆì´ì–´ í•œ ëª…ì´ ê±°ì ˆí•˜ê³  ë‚˜ê°”ìŠµë‹ˆë‹¤.");
                        }
                    }
                });

                newConn.on('close', () => {
                    alert("ë°©ì¥ê³¼ ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤.");
                    location.reload();
                });
            });
        }

        function broadcast(data) {
            connections.forEach(c => {
                if (c && c.open) c.send(data);
            });
        }

        function sendToHost(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }

        function startGameOnline() {
            isOnlineMode = true;
            initGame();
        }

        function handleRestartClick() {
            if (!isOnlineMode) {
                location.reload();
                return;
            }
            
            SoundEffect.playClick();
            document.getElementById('btnRestart').innerText = "ìš”ì²­ ì¤‘...";
            document.getElementById('btnRestart').disabled = true;
            
            // ë³¸ì¸ì€ ìˆ˜ë½í•œ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
            restartVotes[peer.id] = true;
            
            // ìš”ì²­ ì‹œ ë³¸ì¸ì˜ peerIdë¥¼ í•¨ê»˜ ì „ì†¡
            const data = { type: 'restartRequest', peerId: peer.id };
            if (isHost) broadcast(data); else sendToHost(data);
            
            if (isHost && connections.length === 0) {
                resetGameOnline();
            }
        }

        let restartVotes = {}; // í˜¸ìŠ¤íŠ¸ ì „ìš©: {peerId: boolean}

        function showRestartConfirm() {
            const container = document.getElementById('winModalButtons');
            container.innerHTML = `
                <div style="margin-bottom: 10px; color: #1d1d1f; font-weight: 600;">ìƒëŒ€ë°©ì´ í•œ íŒ ë” í•˜ê¸°ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤!</div>
                <button class="btn-primary" onclick="respondToRestart(true)">ìˆ˜ë½</button>
                <button class="btn-secondary" onclick="respondToRestart(false)" style="margin-top: 5px;">ê±°ì ˆ</button>
            `;
        }

        function respondToRestart(accepted) {
            SoundEffect.playClick();
            const data = { type: 'restartResponse', accepted, peerId: peer.id };
            
            if (isHost) {
                handleHostRestartVote(peer.id, accepted);
            } else {
                sendToHost(data);
                if (!accepted) {
                    location.reload();
                } else {
                    document.getElementById('winModalButtons').innerHTML = `<div style="color:#0071e3; font-weight:600;">ë°©ì¥ì˜ ìŠ¹ì¸ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>`;
                }
            }
        }

        function handleHostRestartVote(voterId, accepted) {
            if (!isHost) return;
            
            if (!accepted) {
                // ê±°ì ˆí•œ ìœ ì € ì œê±°
                const leavingTeam = teams.find(t => t.peerId === voterId);
                if (leavingTeam) {
                    showToast("í”Œë ˆì´ì–´ ë‚˜ê°", `${leavingTeam.name}ë‹˜ì´ ê±°ì ˆí•˜ê³  ë‚˜ê°”ìŠµë‹ˆë‹¤.`);
                    teams = teams.filter(t => t.peerId !== voterId);
                }
                // í•´ë‹¹ ì»¤ë„¥ì…˜ ì¢…ë£Œ
                const connToClose = connections.find(c => c.peer === voterId);
                if (connToClose) connToClose.close();
            } else {
                restartVotes[voterId] = true;
                const voterTeam = teams.find(t => t.peerId === voterId);
                if (voterTeam) showToast("ìˆ˜ë½ ì•Œë¦¼", `${voterTeam.name}ë‹˜ì´ ìˆ˜ë½í–ˆìŠµë‹ˆë‹¤.`);
            }

            // ëª¨ë“  í˜„ì¬ ì ‘ì†ìê°€ íˆ¬í‘œí–ˆëŠ”ì§€ í™•ì¸
            const activePeerIds = connections.map(c => c.peer);
            activePeerIds.push(peer.id); // ë°©ì¥ í¬í•¨
            
            const allResponded = activePeerIds.every(id => restartVotes[id] !== undefined);
            
            if (allResponded) {
                const acceptCount = activePeerIds.filter(id => restartVotes[id] === true).length;
                if (acceptCount > 0) {
                    resetGameOnline();
                } else {
                    location.reload();
                }
            }
        }

        function resetGameOnline() {
            document.getElementById('winModal').style.display = 'none';
            restartVotes = {}; // íˆ¬í‘œ ì´ˆê¸°í™”

            // íŒ€ ì •ë³´ ì¬ì •ë ¬ (ë‚˜ê°„ ì‚¬ëŒ ì œì™¸í•˜ê³  IDì™€ ìƒ‰ìƒ ì¬ë°°ì •)
            teams.forEach((t, i) => {
                t.id = i;
                t.color = TEAM_COLORS[i % 4].code;
            });

            // ë‚´ íŒ€ ì¸ë±ìŠ¤ ë‹¤ì‹œ ì°¾ê¸° (ë°©ì¥ì€ ë³´í†µ 0ì´ì§€ë§Œ ì•ˆì „í•˜ê²Œ)
            myTeamIdx = teams.findIndex(t => t.peerId === peer.id);

            // ë²„íŠ¼ ìƒíƒœ ë³µêµ¬
            document.getElementById('winModalButtons').innerHTML = `
                <button id="btnRestart" class="btn-primary" onclick="handleRestartClick()">ë‹¤ì‹œ í•˜ê¸°</button>
                <button id="btnExit" class="btn-secondary" onclick="location.reload()" style="margin-top: 5px;">ë©”ë‰´ë¡œ ë‚˜ê°€ê¸°</button>
            `;
            
            if (isHost) {
                // ë‚¨ì€ ì¸ì›ë“¤ì—ê²Œ ê°±ì‹ ëœ í”Œë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ ì „íŒŒ
                broadcast({
                    type: 'playerList',
                    teams: teams.map(t => ({ name: t.name, color: t.color, avatar: t.avatar })),
                    restart: true
                });

                const initialState = {
                    maxUndos: parseInt(document.getElementById('undoCountInput').value) || 2,
                    tokensPerTeam: parseInt(document.getElementById('tokenCountInput').value) || 2,
                    isPowerUpMode: document.getElementById('powerUpMode').checked,
                    teams: teams.map(t => ({ name: t.name, color: t.color, avatar: t.avatar })),
                    traps: [] 
                };
                
                const s1 = [21, 22, 24, 25], s2 = [26, 27, 28, 29], outer = [16, 17, 18, 19];
                initialState.traps = [
                    { loc: 'shortcut_1', index: s1[Math.floor(Math.random() * s1.length)] },
                    { loc: 'shortcut_2', index: s2[Math.floor(Math.random() * s2.length)] },
                    { loc: 'outer', index: outer[Math.floor(Math.random() * outer.length)] }
                ];

                broadcast({ type: 'gameStarted', initialState });
                initGame(initialState); 
            }
        }

        function handleRemoteAction(action) {
            console.log("Remote action received:", action);
            if (action.type === 'throw') {
                processYutResult(action.results, action.flatCount, action.moveId);
            } else if (action.type === 'fail') {
                // ìƒëŒ€ë°©ì˜ ë‚™ì¥/í˜ë¶€ì¡± ì²˜ë¦¬
                SoundEffect.playFail(); 
                showToast(action.title, action.desc);
                document.getElementById('subResult').innerText = action.desc; 
                setTimeout(() => {
                    const nextIdx = (action.turnIdx + 1) % teams.length;
                    nextTurn(nextIdx);
                }, 1500); 
            } else if (action.type === 'move') {
                executeMove(action.tIdx, action.mId);
            } else if (action.type === 'skill') {
                useSkill(action.skillType, action.tokenIdx, true);
            }
        }

        function showAiDifficultyModal() {
            SoundEffect.playClick();
            document.getElementById('aiDifficultyModal').style.display = 'flex';
        }

        function closeAiModal() {
            SoundEffect.playClick();
            document.getElementById('aiDifficultyModal').style.display = 'none';
        }

        function setAiDifficulty(diff) {
            aiDifficulty = diff;
            const names = { 'easy': 'ğŸ¤– ì´ˆë³´', 'normal': 'ğŸ¤– ë³´í†µ', 'hard': 'ğŸ¤– ê³ ìˆ˜' };
            document.getElementById('aiDifficultyDisplay').innerText = `${names[diff]} âš™ï¸`;
            closeAiModal();
        }

        function initGame(remoteState = null) {
            // ì˜¨ë¼ì¸ ëª¨ë“œì´ê³  ë°©ì¥ì´ë©° ì§ì ‘ ì‹œì‘í•˜ëŠ” ê²½ìš° (ì°¸ê°€ìì—ê²Œ ìƒíƒœ ì „ì†¡)
            if (gameMode === 'online' && isHost && !remoteState && !isOnlineMode) {
                SoundEffect.init();
                const initialState = {
                    maxUndos: parseInt(document.getElementById('undoCountInput').value) || 2,
                    tokensPerTeam: parseInt(document.getElementById('tokenCountInput').value) || 2,
                    isPowerUpMode: document.getElementById('powerUpMode').checked,
                    teams: teams.map(t => ({ name: t.name, color: t.color, avatar: t.avatar })), // íŒ€ ì •ë³´ í¬í•¨
                    traps: [] 
                };
                
                const s1 = [21, 22, 24, 25], s2 = [26, 27, 28, 29], outer = [16, 17, 18, 19];
                initialState.traps = [
                    { loc: 'shortcut_1', index: s1[Math.floor(Math.random() * s1.length)] },
                    { loc: 'shortcut_2', index: s2[Math.floor(Math.random() * s2.length)] },
                    { loc: 'outer', index: outer[Math.floor(Math.random() * outer.length)] }
                ];

                broadcast({ type: 'gameStarted', initialState });
                initGame(initialState); 
                return;
            }

            const state = remoteState || {
                maxUndos: parseInt(document.getElementById('undoCountInput').value) || 2,
                tokensPerTeam: parseInt(document.getElementById('tokenCountInput').value) || 2,
                isPowerUpMode: document.getElementById('powerUpMode').checked,
                traps: []
            };

            SoundEffect.init(); SoundEffect.playClick();
            tokensPerTeam = state.tokensPerTeam;
            gameState.maxUndos = state.maxUndos;
            isPowerUpMode = state.isPowerUpMode;
            // gameMode = modeSelect.value; // ì œê±°
            isOnlineMode = (gameMode === 'online');

            // ì˜¨ë¼ì¸ ëª¨ë“œì¼ ë•Œ íŒ€ ì •ë³´ ë™ê¸°í™”
            if (state.teams) {
                state.teams.forEach((t, i) => {
                    if (!teams[i]) {
                        teams[i] = { id: i, tokens: [], remainingUndos: state.maxUndos, sp: 3, isAi: false };
                    }
                    teams[i].name = t.name;
                    teams[i].color = t.color;
                    teams[i].avatar = t.avatar;
                });
            } else {
                if (gameMode === 'ai') {
                    if (teams.length > 2) teams = teams.slice(0, 2);
                    const aiNames = { 'easy': 'ê¼¬ë§ˆ ë„ì•¼', 'normal': 'ì˜ë¦¬í•œ ë—ê°œ', 'hard': 'ì „ì„¤ì˜ ìœ·ì‹ ' };
                    teams[0].isAi = false; teams[1].isAi = true; teams[1].name = aiNames[aiDifficulty] || 'AI';
                } else if (gameMode === 'multi') { 
                    teams.forEach((t, i) => { t.isAi = false; t.name = TEAM_COLORS[i%4].name; t.color = TEAM_COLORS[i%4].code; }); 
                }
            }
            
            teams.forEach(t => { 
                t.remainingUndos = state.maxUndos; 
                t.sp = 3; 
                t.tokens = []; 
                for(let i=0; i<tokensPerTeam; i++) {
                    t.tokens.push({ id: i, index: 0, location: 'outer', finished: false, shielded: false }); 
                }
            });

            if (state.traps && state.traps.length > 0) {
                gameState.traps = state.traps;
            } else if (!isOnlineMode) {
                gameState.traps = [];
                const s1 = [21, 22, 24, 25], s2 = [26, 27, 28, 29], outer = [16, 17, 18, 19];
                gameState.traps.push({ loc: 'shortcut_1', index: s1[Math.floor(Math.random() * s1.length)] });
                gameState.traps.push({ loc: 'shortcut_2', index: s2[Math.floor(Math.random() * s2.length)] });
                gameState.traps.push({ loc: 'outer', index: outer[Math.floor(Math.random() * outer.length)] });
            }

            document.getElementById('setupArea').style.display = 'none'; 
            document.getElementById('gameWrapper').style.display = 'flex';
            if (isPowerUpMode) { 
                document.getElementById('skillArea').style.display = 'flex'; 
                document.getElementById('spDisplay').style.display = 'inline'; 
            }
            
            gameState.step = 'THROW'; 
            gameState.currentTeamIdx = 0; 
            gameState.moveQueue = [];

            GameStats.resetSession(); drawBoardDots(); updateBoardVisuals(); updateTurnUI();
            setTimeout(optimizeLayout, 100);
        }

        let isCharging = false, power = 0, direction = 1, animId = null;
        function toggleThrow() { 
            if (isOnlineMode && gameState.currentTeamIdx !== myTeamIdx) return;
            if (!isCharging) startGauge(); else stopGauge(); 
        }
        function startGauge() {
            SoundEffect.playStartGauge(); isCharging = true;
            document.getElementById('actionBtn').innerText = "ë©ˆì¶”ê¸° (STOP)"; document.getElementById('actionBtn').style.backgroundColor = "#ff3b30";
            document.getElementById('subResult').innerText = "í˜ ì¡°ì ˆ ì¤‘..."; loopGauge();
        }
        function loopGauge() {
            if (!isCharging) return; power += direction * 2.5;
            if (power >= 100) { power=100; direction=-1; } else if (power <= 0) { power=0; direction=1; }
            document.getElementById('powerBar').style.width = power + "%";
            document.getElementById('powerBar').style.background = (power <= 10 || power >= 90) ? '#ff3b30' : '#34c759';
            animId = requestAnimationFrame(loopGauge);
        }
        function stopGauge() { isCharging = false; cancelAnimationFrame(animId); document.getElementById('actionBtn').disabled = true; handleThrowResult(power); }
        function handleThrowResult(p) { if (p <= 10) handleFail("âŒ í˜ ë¶€ì¡±", "ë„ˆë¬´ ì•½í–ˆìŠµë‹ˆë‹¤."); else if (p >= 90) handleFail("âš ï¸ ë‚™ì¥!", "ë„ˆë¬´ ê°•í–ˆìŠµë‹ˆë‹¤."); else calculateYutResult(); }
        function handleFail(t, d) { 
            // ì˜¨ë¼ì¸ ëª¨ë“œì¼ ë•Œ ì‹¤íŒ¨ ì •ë³´ ì „ì†¡ (í˜„ì¬ í„´ ë²ˆí˜¸ í¬í•¨)
            if (isOnlineMode && gameState.currentTeamIdx === myTeamIdx) {
                const data = { type: 'action', action: { type: 'fail', title: t, desc: d, turnIdx: gameState.currentTeamIdx } };
                if (isHost) broadcast(data); else sendToHost(data);
            }
            
            SoundEffect.playFail(); 
            showToast(t, d);
            document.getElementById('subResult').innerText = d; 
            setTimeout(() => {
                // ë‹¤ìŒ í„´ìœ¼ë¡œ ë„˜ê¸¸ ë•Œ ë°©ì¥ì´ë©´ ê°•ì œë¡œ ë‹¤ìŒ ì¸ë±ìŠ¤ë¥¼ ê³„ì‚°í•´ì„œ ë„˜ê¹€
                const nextIdx = (gameState.currentTeamIdx + 1) % teams.length;
                nextTurn(nextIdx);
            }, 1500); 
        }

        function calculateYutResult() {
            let flatCount = 0, results = [];
            for(let i=0; i<4; i++) { let isFlat = Math.random() < 0.52; results.push(isFlat); if(isFlat) flatCount++; }
            
            const moveId = Date.now(); // ê³ ìœ  ì´ë™ ID ìƒì„±

            // ì˜¨ë¼ì¸ ëª¨ë“œì¼ ë•Œ ê²°ê³¼ ì „ì†¡
            if (isOnlineMode && gameState.currentTeamIdx === myTeamIdx) {
                const data = { type: 'action', action: { type: 'throw', results, flatCount, moveId } };
                if (isHost) broadcast(data); else sendToHost(data);
            }

            processYutResult(results, flatCount, moveId);
        }

        function processYutResult(results, flatCount, moveId = null) {
            updateSticks(results);
            let score = 0, text = "", isBackDo = false;
            switch(flatCount) {
                case 1: if (results[3]) { text = "ë°±ë„"; score = -1; isBackDo = true; } else { text = "ë„"; score = 1; } break;
                case 2: text="ê°œ"; score=2; break;
                case 3: text="ê±¸"; score=3; break;
                case 4: text="ìœ·"; score=4; break;
                case 0: text="ëª¨"; score=5; break;
            }
            const resultText = `${isBackDo ? 'ğŸ”™' : 'ğŸ‰'} ${text}!`;
            showToast(resultText, "ì´ë™í•  ë§ì„ ì„ íƒí•˜ì„¸ìš”.");
            
            const finalMoveId = moveId || Date.now();
            gameState.moveQueue.push({ id: finalMoveId, score, text });
            
            if (!teams[gameState.currentTeamIdx].isAi && (score >= 4)) GameStats.currentSession.yutMoCount++;
            if (score >= 4) SoundEffect.playGoodThrow(); else SoundEffect.playYutThrow();
            if (score >= 4) { 
                document.getElementById('subResult').innerText = "ìœ·/ëª¨! í•œ ë²ˆ ë”!"; 
                setTimeout(() => { 
                    if (!teams[gameState.currentTeamIdx].isAi) {
                        if (!isOnlineMode || gameState.currentTeamIdx === myTeamIdx) {
                            document.getElementById('actionBtn').disabled = false; 
                            document.getElementById('actionBtn').innerText = "ë˜ì§€ê¸° (í•œë²ˆ ë”!)"; 
                        }
                    }
                    updateAvailableMovesUI(); 
                    maybeTriggerAi(); 
                }, 1000); 
            }
            else { document.getElementById('subResult').innerText = "ë§ì„ ì„ íƒí•˜ì„¸ìš”."; setTimeout(prepareMoveStep, 800); }
        }

        function updateSticks(res) { for(let i=0; i<4; i++) { sticks[i].className = 'stick' + (res[i] ? ' flat' : ' round'); if (i === 3) sticks[i].classList.add('back-do-mark'); } }
        function prepareMoveStep() { gameState.step = 'MOVE'; document.getElementById('gaugeArea').style.display = 'none'; document.getElementById('moveArea').style.display = 'block'; updateAvailableMovesUI(); if (gameState.moveQueue.length > 0 && !gameState.selectedMoveId) selectMove(gameState.moveQueue[0].id); else if (gameState.moveQueue.length === 0) nextTurn(); maybeTriggerAi(); }
        function updateAvailableMovesUI() { document.getElementById('availableMoves').innerHTML = ""; gameState.moveQueue.forEach(m => { const c = document.createElement('div'); c.className = 'move-chip' + (m.score === -1 ? ' back-do' : '') + (m.id === gameState.selectedMoveId ? ' selected' : ''); c.innerText = m.text; c.onclick = () => { if (gameState.step === 'MOVE') { SoundEffect.playClick(); selectMove(m.id); } }; document.getElementById('availableMoves').appendChild(c); }); }
        function selectMove(id) { gameState.selectedMoveId = id; updateAvailableMovesUI(); renderTokenOptions(); }

        function renderTokenOptions() {
            document.getElementById('moveOptions').innerHTML = "";
            const team = teams[gameState.currentTeamIdx]; const move = gameState.moveQueue.find(m => m.id === gameState.selectedMoveId);
            if (!move) return; let v = 0;
            team.tokens.forEach((t, i) => {
                if (t.finished) return; const pre = simulateMove(t, move.score);
                if (!pre.invalidMove) v++;
            });
            if (v === 0) { document.getElementById('subResult').innerText = "ì´ë™ë¶ˆê°€ íŒ¨ ì†Œë©¸"; setTimeout(() => executeMove(-1, move.id), 1200); }
            updateBoardVisuals();
        }

        function showToast(title, msg, duration = 1500) {
            const toast = document.getElementById('toastModal');
            document.getElementById('toastTitle').innerText = title;
            document.getElementById('toastMsg').innerText = msg;
            toast.style.display = 'block';
            setTimeout(() => { toast.style.display = 'none'; }, duration);
        }

        async function executeMove(tIdx, mId) {
            // ì˜¨ë¼ì¸ ëª¨ë“œ ë™ê¸°í™”
            if (isOnlineMode && gameState.currentTeamIdx === myTeamIdx) {
                const data = { type: 'action', action: { type: 'move', tIdx, mId } };
                if (isHost) broadcast(data); else sendToHost(data);
            }

            historyState = { gameSnapshot: JSON.parse(JSON.stringify({ teams, gameState })), whoMovedIdx: gameState.currentTeamIdx };
            const mIdx = gameState.moveQueue.findIndex(m => m.id === mId); const score = gameState.moveQueue[mIdx].score;
            gameState.moveQueue.splice(mIdx, 1); gameState.selectedMoveId = null;
            let catchFlag = false, team = teams[gameState.currentTeamIdx];
            if (tIdx !== -1) {
                const sel = team.tokens[tIdx]; const toMove = sel.index === 0 ? [sel] : team.tokens.filter(t => !t.finished && t.index === sel.index && t.location === sel.location);
                if (!team.isAi) GameStats.currentSession.maxStacked = Math.max(GameStats.currentSession.maxStacked, toMove.length);
                const finalState = simulateMove(sel, score);
                const steps = Math.abs(score), fwd = score > 0;
                for (let s = 1; s <= steps; s++) {
                    toMove.forEach(t => { const r = simulateMove(t, fwd ? 1 : -1, true); t.index = r.finalIdx; t.location = r.loc; t.finished = r.finished; });
                    SoundEffect.playMove(); updateBoardVisuals(); if (s < steps) await new Promise(r => setTimeout(r, 400));
                }
                toMove.forEach(t => { t.index = finalState.finalIdx; t.location = finalState.loc; t.finished = finalState.finished; });
                
                // í•¨ì • ì²´í¬ ë¡œì§ ì¶”ê°€
                const isTrap = gameState.traps.some(tr => tr.loc === finalState.loc && tr.index === finalState.finalIdx);
                if (isTrap) {
                    toMove.forEach(t => { t.index = 0; t.location = 'outer'; t.shielded = false; });
                    SoundEffect.playFail(); 
                    showToast("ğŸ•¸ï¸ í•¨ì •!", "í•¨ì •ì— ë¹ ì ¸ ì¶œë°œì§€ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.");
                    shakeBoard();
                    updateBoardVisuals();
                } else {
                    let actualCatch = false;
                    teams.forEach((tm, ti) => {
                        if (ti === gameState.currentTeamIdx) return;
                        tm.tokens.forEach(e => {
                            if (!e.finished && e.index !== 0 && e.index === finalState.finalIdx && e.location === finalState.loc) {
                                if (e.shielded) { e.shielded = false; showMessage("ğŸ›¡ï¸ ë°©ì–´ë§‰ ë³´í˜¸!", "#34c759"); if(!tm.isAi) GameStats.unlockAchievement('SHIELD_SUCCESS'); }
                                else { e.index = 0; e.location = 'outer'; catchFlag = true; actualCatch = true; if (isPowerUpMode) team.sp = Math.min(5, team.sp + 1); if(!team.isAi) GameStats.currentSession.captures++; }
                            }
                        });
                    });
                    if (actualCatch) { shakeBoard(); SoundEffect.playCatch(); showMessage("ğŸ¯ ì¡ì•˜ë‹¤! í•œ ë²ˆ ë”!", "#ff3b30"); }
                }
                if (toMove.some(t => t.finished)) { SoundEffect.playGoodThrow(); showMessage("ğŸ ì™„ì£¼ ì„±ê³µ!", "#0071e3"); }
            }
            updateBoardVisuals(); if (checkWin()) return;
            if (team.remainingUndos > 0 && !isOnlineMode) { 
                document.getElementById('btnUndo').innerText = `â†©`; 
                document.getElementById('btnUndo').style.display = 'flex'; 
            }
            if (catchFlag) { setTimeout(() => { gameState.step = 'THROW'; updateTurnUI(); }, 1000); return; }
            if (gameState.moveQueue.length > 0) prepareMoveStep(); else setTimeout(nextTurn, 1000);
        }

        function simulateMove(token, steps, isAnim = false) {
            let sim = { idx: token.index, loc: token.location, finished: false, catch: false, finalIdx: 0, invalidMove: false };
            if (steps === -1) {
                if (sim.idx === 0) { sim.invalidMove = true; return sim; }
                if (sim.loc === 'outer') { if (sim.idx === 1) sim.idx = 20; else sim.idx--; }
                else if (sim.loc === 'shortcut_1') { if (sim.idx === 21 || sim.idx === 5) { sim.idx = 4; sim.loc = 'outer'; } else if (sim.idx === 23) sim.idx = 22; else sim.idx--; }
                else if (sim.loc === 'shortcut_2') { if (sim.idx === 26 || sim.idx === 10) { sim.idx = 9; sim.loc = 'outer'; } else if (sim.idx === 23) sim.idx = 27; else sim.idx--; }
            } else {
                for(let i=0; i<Math.abs(steps); i++) {
                    if (sim.loc === 'outer') { sim.idx++; if (sim.idx > 20) { sim.finished = true; break; } }
                    else if (sim.loc === 'shortcut_1') { if (sim.idx === 5) sim.idx = 21; else if (sim.idx === 25) { sim.idx = 15; sim.loc = 'outer'; } else sim.idx++; }
                    else if (sim.loc === 'shortcut_2') { if (sim.idx === 10) sim.idx = 26; else if (sim.idx === 27) sim.idx = 23; else if (sim.idx === 23) sim.idx = 28; else if (sim.idx === 29) { sim.idx = 20; sim.loc = 'outer'; } else sim.idx++; }
                }
            }
            if (!sim.finished && !sim.invalidMove && !isAnim) {
                if (sim.loc === 'outer') { if (sim.idx === 5) sim.loc = 'shortcut_1'; else if (sim.idx === 10) sim.loc = 'shortcut_2'; }
                else if (sim.loc === 'shortcut_1' && sim.idx === 23) sim.loc = 'shortcut_2';
            }
            sim.finalIdx = sim.idx;
            if(!sim.finished && !sim.invalidMove) { teams.forEach((tm, ti) => { if (ti === gameState.currentTeamIdx) return; tm.tokens.forEach(e => { if (!e.finished && e.index !== 0 && e.index === sim.finalIdx && e.location === sim.loc) sim.catch = true; }); }); }
            return sim;
        }

        function updateBoardVisuals() {
            tokenLayer.innerHTML = ""; let occ = {};
            teams.forEach(team => {
                team.tokens.forEach(t => {
                    if (t.finished) return; if (t.index === 0) { drawToken(t, team.color, 360+(team.id*10), 360-(t.id*10)); return; }
                    const k = `${t.location}_${t.index}`; if (!occ[k]) occ[k] = 0; const off = occ[k]*5; occ[k]++;
                    const pos = getCoords(t.index, t.location); drawToken(t, team.color, pos.x+off, pos.y-off);
                });
            });
        }

        async function useSkill(type, tokenIdx = -1, isRemote = false) {
            const team = teams[gameState.currentTeamIdx]; if (!isPowerUpMode) return;
            
            // ì˜¨ë¼ì¸ ëª¨ë“œ ì°¨ë¡€ í™•ì¸ (ì›ê²© ìš”ì²­ì´ ì•„ë‹ ë•Œë§Œ)
            if (isOnlineMode && !isRemote && gameState.currentTeamIdx !== myTeamIdx) return;

            // ì‚¬ëŒ í”Œë ˆì´ì–´ì´ê³  ë§ì„ ì„ íƒí•˜ì§€ ì•Šì€ ê²½ìš° ì„ íƒì°½ í‘œì‹œ (ì›ê²© ì•„ë‹ ë•Œë§Œ)
            if (!isRemote && !team.isAi && (type === 'shield' || type === 'boost') && tokenIdx === -1) {
                gameState.selectedSkillType = type;
                renderSkillTokenOptions(type);
                return;
            }

            // ì˜¨ë¼ì¸ ëª¨ë“œ ë™ê¸°í™” (ë‚´ê°€ ì§ì ‘ ì‚¬ìš©í•  ë•Œë§Œ)
            if (isOnlineMode && !isRemote && gameState.currentTeamIdx === myTeamIdx) {
                const data = { type: 'action', action: { type: 'skill', skillType: type, tokenIdx } };
                if (isHost) broadcast(data); else sendToHost(data);
            }

            if (type === 'shield') {
                const target = tokenIdx !== -1 ? team.tokens[tokenIdx] : team.tokens.find(t => t.index > 0 && !t.finished && !t.shielded);
                if (!target) { gameState.selectedSkillType = null; return team.isAi ? null : alert("ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤."); }
                team.sp -= 1; target.shielded = true; 
                showToast("ğŸ›¡ï¸ ë°©ì–´ë§‰ ì‚¬ìš©", `${team.name}ì˜ ë§ì´ ë³´í˜¸ë°›ìŠµë‹ˆë‹¤.`);
                document.getElementById('moveArea').style.display = 'none';
                if (gameState.step === 'MOVE') prepareMoveStep(); else updateTurnUI();
            } else if (type === 'reroll') {
                if (gameState.step !== 'MOVE' || team.sp < 1) return;
                team.sp -= 1; gameState.moveQueue = []; gameState.step = 'THROW'; 
                showToast("ğŸ”„ ì¬ë„ì „ ì‚¬ìš©", "ë˜ì§€ê¸° ê²°ê³¼ê°€ ì·¨ì†Œë˜ê³  ë‹¤ì‹œ ë˜ì§‘ë‹ˆë‹¤.");
            } else if (type === 'boost') {
                const target = tokenIdx !== -1 ? team.tokens[tokenIdx] : team.tokens.find(t => !t.finished);
                if (!target || team.sp < 2) { gameState.selectedSkillType = null; return team.isAi ? null : alert("ë¶ˆê°€"); }
                team.sp -= 2; 
                
                showToast("âš¡ ë¶€ìŠ¤íŠ¸ ì‚¬ìš©", `${team.name}ì˜ ë§ì´ 2ì¹¸ ì „ì§„í•©ë‹ˆë‹¤.`);
                // ì„ íƒì°½ UI ë‹«ê¸°
                document.getElementById('moveArea').style.display = 'none';
                
                const finalSim = simulateMove(target, 2);
                const toMove = target.index === 0 ? [target] : team.tokens.filter(t => !t.finished && t.index === target.index && t.location === target.location);
                for (let s = 1; s <= 2; s++) { toMove.forEach(t => { const r = simulateMove(t, 1, true); t.index = r.finalIdx; t.location = r.loc; t.finished = r.finished; }); SoundEffect.playMove(); updateBoardVisuals(); await new Promise(r => setTimeout(r, 400)); }
                toMove.forEach(t => { t.index = finalSim.finalIdx; t.location = finalSim.loc; t.finished = finalSim.finished; });
                
                const isTrap = gameState.traps.some(tr => tr.loc === finalSim.loc && tr.index === finalSim.finalIdx);
                if (isTrap) {
                    toMove.forEach(t => { t.index = 0; t.location = 'outer'; t.shielded = false; });
                    SoundEffect.playFail(); 
                    showToast("ğŸ•¸ï¸ í•¨ì •!", "í•¨ì •ì— ë¹ ì ¸ ì¶œë°œì§€ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.");
                    shakeBoard(); updateBoardVisuals();
                } else {
                    let c = false;
                    teams.forEach((tm, ti) => {
                        if (ti === gameState.currentTeamIdx) return;
                        tm.tokens.forEach(e => {
                            if (!e.finished && e.index !== 0 && e.index === finalSim.finalIdx && e.location === finalSim.loc) {
                                if (e.shielded) { e.shielded = false; showMessage("ğŸ›¡ï¸ ë°©ì–´ë§‰ ë³´í˜¸!", "#34c759"); }
                                else { e.index = 0; e.location = 'outer'; c = true; team.sp = Math.min(5, team.sp + 1); if(!team.isAi) { GameStats.currentSession.captures++; GameStats.unlockAchievement('BOOST_CATCH'); } }
                            }
                        });
                    });
                    if (c) { shakeBoard(); SoundEffect.playCatch(); showMessage("ğŸ¯ ë¶€ìŠ¤íŠ¸ ì¡ê¸°! í•œ ë²ˆ ë”!", "#ff3b30"); gameState.step = 'THROW'; }
                    else showMessage(`${team.name}: âš¡ ë¶€ìŠ¤íŠ¸!`, "#0071e3");
                }
            }
            gameState.selectedSkillType = null;
            updateTurnUI(); updateBoardVisuals(); checkWin();
        }

        function renderSkillTokenOptions(type) {
            const team = teams[gameState.currentTeamIdx];
            const moveArea = document.getElementById('moveArea');
            const optionsContainer = document.getElementById('moveOptions');
            const availableMoves = document.getElementById('availableMoves');
            
            moveArea.style.display = 'block';
            document.getElementById('gaugeArea').style.display = 'none'; 
            
            // íŒ¨ ì„ íƒ ì˜ì—­ì— ì¹©ê³¼ ì·¨ì†Œ ë²„íŠ¼ì„ í•¨ê»˜ ë°°ì¹˜
            availableMoves.innerHTML = "";
            const chip = document.createElement('div');
            chip.className = 'move-chip selected';
            chip.style.background = '#0071e3';
            chip.style.borderColor = '#0071e3';
            chip.innerText = type === 'shield' ? 'ğŸ›¡ï¸ ë°©ì–´ë§‰ ëŒ€ìƒ ì„ íƒ' : 'âš¡ ë¶€ìŠ¤íŠ¸ ëŒ€ìƒ ì„ íƒ';
            availableMoves.appendChild(chip);

            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'move-chip';
            cancelBtn.style.background = '#8e8e93';
            cancelBtn.style.color = 'white';
            cancelBtn.innerText = "ì·¨ì†Œ";
            cancelBtn.onclick = () => {
                SoundEffect.playClick();
                gameState.selectedSkillType = null;
                updateTurnUI();
                if (gameState.step === 'MOVE') prepareMoveStep();
                else moveArea.style.display = 'none';
            };
            availableMoves.appendChild(cancelBtn);

            optionsContainer.innerHTML = "";
            updateBoardVisuals();
        }

        function handleTokenClick(t) {
            if (isOnlineMode && gameState.currentTeamIdx !== myTeamIdx) return; // ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œ ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆë©´ ë¬´ì‹œ
            const team = teams[gameState.currentTeamIdx];
            if (!team || team.isAi) return;
            const tIdx = team.tokens.indexOf(t);
            if (tIdx === -1) return;

            if (gameState.selectedSkillType) {
                useSkill(gameState.selectedSkillType, tIdx);
            } else if (gameState.step === 'MOVE') {
                const move = gameState.moveQueue.find(m => m.id === gameState.selectedMoveId);
                if (move) {
                    const pre = simulateMove(t, move.score);
                    if (!pre.invalidMove) {
                        executeMove(tIdx, move.id);
                    }
                }
            }
        }

        function drawToken(t, color, cx, cy) {
            const team = teams.find(tm => tm.tokens.includes(t));
            const isCurrentTeam = (gameState.step !== 'SETUP' && teams[gameState.currentTeamIdx] === team);
            let isSelectable = false;
            
            // ë‚´ ì°¨ë¡€ì¼ ë•Œë§Œ ì„ íƒ ê°€ëŠ¥í•˜ë„ë¡ ê°•í™”
            if (isCurrentTeam && !team.isAi && (!isOnlineMode || gameState.currentTeamIdx === myTeamIdx)) {
                if (gameState.selectedSkillType) {
                    if (!t.finished) {
                        if (gameState.selectedSkillType === 'shield') {
                            if (t.index > 0 && !t.shielded) isSelectable = true;
                        } else if (gameState.selectedSkillType === 'boost') {
                            isSelectable = true;
                        }
                    }
                } else if (gameState.step === 'MOVE') {
                    const move = gameState.moveQueue.find(m => m.id === gameState.selectedMoveId);
                    if (move) {
                        const pre = simulateMove(t, move.score);
                        if (!pre.invalidMove) isSelectable = true;
                    }
                }
            }

            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            if (isSelectable) {
                g.style.cursor = "pointer";
                g.onclick = (e) => { e.stopPropagation(); handleTokenClick(t); };
                
                const h = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                h.setAttribute("cx", cx); h.setAttribute("cy", cy); h.setAttribute("r", 15);
                h.setAttribute("fill", "none"); h.setAttribute("stroke", color);
                h.setAttribute("stroke-width", "2"); h.setAttribute("stroke-dasharray", "4,2");
                
                const anim = document.createElementNS("http://www.w3.org/2000/svg", "animate");
                anim.setAttribute("attributeName", "r");
                anim.setAttribute("from", "13");
                anim.setAttribute("to", "18");
                anim.setAttribute("dur", "1s");
                anim.setAttribute("repeatCount", "indefinite");
                h.appendChild(anim);

                const opac = document.createElementNS("http://www.w3.org/2000/svg", "animate");
                opac.setAttribute("attributeName", "opacity");
                opac.setAttribute("from", "1");
                opac.setAttribute("to", "0");
                opac.setAttribute("dur", "1s");
                opac.setAttribute("repeatCount", "indefinite");
                h.appendChild(opac);
                
                g.appendChild(h);
            }

            if (t.shielded) { const s = document.createElementNS("http://www.w3.org/2000/svg", "circle"); s.setAttribute("cx", cx); s.setAttribute("cy", cy); s.setAttribute("r", 16); s.setAttribute("fill", "none"); s.setAttribute("stroke", "#34c759"); s.setAttribute("stroke-width", "3"); s.setAttribute("stroke-dasharray", "4,2"); g.appendChild(s); }
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle"); c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", 12); c.setAttribute("fill", color); c.setAttribute("class", "token"); c.setAttribute("stroke", "white"); c.setAttribute("stroke-width", "2");
            const emojis = { 'easy':'ğŸ·', 'normal':'ğŸ¶', 'hard':'ğŸ‰' }, tEmojis = ['ğŸ¯', 'ğŸ°', 'ğŸ¸', 'ğŸ¥'];
            const txt = document.createElementNS("http://www.w3.org/2000/svg", "text"); txt.setAttribute("x", cx); txt.setAttribute("y", cy); txt.setAttribute("dy", 4); txt.setAttribute("font-size", "14"); txt.setAttribute("text-anchor", "middle"); txt.textContent = team.isAi ? (emojis[aiDifficulty]||'ğŸ¤–') : tEmojis[team.id%4];
            const idTxt = document.createElementNS("http://www.w3.org/2000/svg", "text"); idTxt.setAttribute("x", cx+8); idTxt.setAttribute("y", cy-8); idTxt.setAttribute("font-size", "8"); idTxt.setAttribute("font-weight", "bold"); idTxt.setAttribute("fill", "white"); idTxt.setAttribute("stroke", "black"); idTxt.setAttribute("stroke-width", "0.5"); idTxt.textContent = t.id + 1;
            g.appendChild(c); g.appendChild(txt); g.appendChild(idTxt); tokenLayer.appendChild(g);
        }

        function maybeTriggerAi() {
            const team = teams[gameState.currentTeamIdx]; if (!team || !team.isAi) return;
            if (aiTimeoutId) { clearTimeout(aiTimeoutId); aiTimeoutId = null; }
            if (aiTryUseSkill()) return;
            if (gameState.step === 'THROW') aiTimeoutId = setTimeout(aiStartThrowing, aiActionDelay);
            else if (gameState.step === 'MOVE' && gameState.moveQueue.length > 0) aiTimeoutId = setTimeout(aiExecuteCurrentMove, aiActionDelay);
        }
        function aiStartThrowing() {
            const team = teams[gameState.currentTeamIdx];
            if (!team || !team.isAi || gameState.step !== 'THROW') return;
            
            document.getElementById('gaugeArea').style.display = 'block';
            document.getElementById('actionBtn').disabled = true;
            document.getElementById('actionBtn').innerText = "AIê°€ ì¡°ì ˆ ì¤‘...";
            startGauge();
            const targetPower = Math.floor(Math.random() * 60) + 25;
            const holdTime = (targetPower / 2.5) * (1000 / 60) * 1.1; 
            aiTimeoutId = setTimeout(() => { 
                if (gameState.currentTeamIdx === team.id && gameState.step === 'THROW') stopGauge(); 
            }, holdTime);
        }
        function aiTryUseSkill() {
            const team = teams[gameState.currentTeamIdx]; if (team.sp <= 0 || !isPowerUpMode) return false;
            if (team.sp >= 2) { 
                for(let i=0; i<team.tokens.length; i++) { 
                    const t = team.tokens[i]; if(t.finished) continue; 
                    const pre = simulateMove(t, 2); 
                    if(pre.catch || pre.finished || (t.index===0 && Math.random()<0.3)) { 
                        const targetIdx = i; // ì¸ë±ìŠ¤ ì €ì¥
                        aiTimeoutId = setTimeout(()=> {
                            if (gameState.currentTeamIdx === team.id) useSkill('boost', targetIdx);
                        }, 600); return true; 
                    } 
                } 
            }
            if (team.sp >= 1) { 
                const targetIdx = team.tokens.findIndex(t => t.index > 0 && !t.finished && !t.shielded && enemyCaptureThreat({ loc: t.location, finalIdx: t.index }) > 100); 
                if (targetIdx !== -1) { 
                    aiTimeoutId = setTimeout(()=> {
                        if (gameState.currentTeamIdx === team.id) useSkill('shield', targetIdx);
                    }, 600); return true; 
                } 
            }
            return false;
        }
        function aiExecuteCurrentMove() {
            const team = teams[gameState.currentTeamIdx]; 
            if (!team || !team.isAi || gameState.step !== 'MOVE') return;
            
            let best = { tIdx: -1, mId: -1, val: -Infinity };
            for(const m of gameState.moveQueue) { team.tokens.forEach((t, i) => { if(t.finished) return; const res = evaluateAiMove(t, m); if(res.value > best.val) best = { tIdx: i, mId: m.id, val: res.value }; }); }
            if (best.tIdx !== -1) executeMove(best.tIdx, best.mId);
        }
        function evaluateAiMove(token, move) {
            const pre = simulateMove(token, move.score); if (pre.invalidMove) return { value: -Infinity };
            const weights = { 'easy': { dist:20, capture:200, finish:500, shortcut:50, threat:0.1, stacking:20 }, 'normal': { dist:40, capture:800, finish:1000, shortcut:250, threat:0.6, stacking:120 }, 'hard': { dist:60, capture:1500, finish:2000, shortcut:500, threat:1.2, stacking:200 } };
            const w = weights[aiDifficulty] || weights['normal'];
            let val = (getStepsToFinish(token) - getStepsToFinish({index:pre.finalIdx, location:pre.loc, finished:pre.finished})) * w.dist;
            if (pre.catch) val += w.capture; if (pre.finished) val += w.finish;
            
            // AI í•¨ì • íšŒí”¼ ë¡œì§ ì¶”ê°€
            const isTrap = gameState.traps.some(tr => tr.loc === pre.loc && tr.index === pre.finalIdx);
            if (isTrap) val -= 3000; // í•¨ì •ì€ ë§¤ìš° í° ê°ì 
            if (token.location === 'outer' && pre.loc.startsWith('shortcut')) val += w.shortcut;
            if (teams[gameState.currentTeamIdx].tokens.some(t => !t.finished && t !== token && t.index === pre.finalIdx && t.location === pre.loc) && pre.finalIdx !== 0) val += w.stacking;
            if (!pre.finished) val -= enemyCaptureThreat(pre) * w.threat;
            if (move.score >= 4) val += 100;
            if (aiDifficulty === 'easy') val += (Math.random()-0.5)*150;
            return { value: val, preview: pre };
        }
        function getStepsToFinish(t) { if (t.finished) return 0; let s = 0, sim = { index: t.index, location: t.location, finished: t.finished }; while (!sim.finished && s < 30) { sim = simulateMove(sim, 1); s++; } return s; }
        function enemyCaptureThreat(snap) { let th = 0; teams.forEach((tm, ti) => { if(ti===gameState.currentTeamIdx) return; tm.tokens.forEach(e => { if(e.finished||e.index===0)return; [1,2,3,4,5].forEach(st => { const p = simulateMove(e, st); if(!p.invalidMove && p.loc===snap.loc && p.finalIdx===snap.finalIdx) th += 300-(st*20); }); }); }); return Math.min(Math.max(th, 0), 500); }

        function showRules() { SoundEffect.playClick(); document.getElementById('ruleModal').style.display = 'flex'; }
        function closeRules() { SoundEffect.playClick(); document.getElementById('ruleModal').style.display = 'none'; }
        function showStats() {
            SoundEffect.playClick(); const d = GameStats.data;
            document.getElementById('statTotalGames').innerText = d.totalGames; document.getElementById('statWins').innerText = d.wins;
            document.getElementById('statWinRate').innerText = `${d.totalGames > 0 ? Math.round((d.wins/d.totalGames)*100) : 0}%`;
            document.getElementById('statMaxCaptures').innerText = d.maxCaptures;
            ['FIRST_WIN', 'YUT_GOD', 'CATCH_MASTER', 'STACK_KING', 'BOOST_CATCH', 'SHIELD_SUCCESS'].forEach(id => { const el = document.getElementById(`badge_${id}`); if (d.achievements.includes(id)) el.classList.add('active'); else el.classList.remove('active'); });
            document.getElementById('statsModal').style.display = 'flex';
        }
        function closeStats() { SoundEffect.playClick(); document.getElementById('statsModal').style.display = 'none'; }
        function shakeBoard() { const b = document.querySelector('.board-section'); b.classList.add('shake'); setTimeout(() => b.classList.remove('shake'), 400); }
        function checkWin() { const team = teams[gameState.currentTeamIdx]; if (team.tokens.every(t => t.finished)) { gameState.step = 'END'; SoundEffect.playWin(); document.getElementById('winTitle').innerText = `${team.name} ìŠ¹ë¦¬!`; document.getElementById('winTitle').style.color = team.color; GameStats.recordGameEnd(gameMode==='ai'?!team.isAi:true); document.getElementById('winModal').style.display = 'flex'; fireConfetti(); return true; } return false; }
        function fireConfetti() { const canvas = document.getElementById('confettiCanvas'); canvas.style.display = 'block'; const ctx = canvas.getContext('2d'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; const pieces = [], colors = ['#0071e3', '#ff3b30', '#34c759', '#ffcc00', '#af52de', '#ff9500']; for(let i=0; i<150; i++) pieces.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height-canvas.height, color: colors[i%colors.length], size: Math.random()*8+4, speedY: Math.random()*3+2, speedX: Math.random()*2-1, rot: Math.random()*360, rotS: Math.random()*10-5 }); function anim() { if (gameState.step !== 'END') return; ctx.clearRect(0,0,canvas.width,canvas.height); pieces.forEach(p => { p.y += p.speedY; p.x += p.speedX; p.rot += p.rotS; if (p.y > canvas.height) { p.y = -20; p.x = Math.random()*canvas.width; } ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rot*Math.PI/180); ctx.fillStyle = p.color; ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size); ctx.restore(); }); requestAnimationFrame(anim); } anim(); }
        function undoLastMove() { 
            if (isOnlineMode) return; // ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œëŠ” ë¬´ë¥´ê¸° ê¸°ëŠ¥ì„ ì œí•œí•©ë‹ˆë‹¤ (ë™ê¸°í™” ì´ìŠˆ ë°©ì§€)
            if (!historyState) return; 
            SoundEffect.playClick(); 
            const teamIdx = historyState.whoMovedIdx; 
            if (teams[teamIdx].remainingUndos <= 0) return; 
            const snapshot = historyState.gameSnapshot; 
            teams = snapshot.teams; 
            gameState = snapshot.gameState; 
            teams[teamIdx].remainingUndos--; 
            historyState = null; 
            document.getElementById('btnUndo').style.display = 'none'; 
            updateBoardVisuals(); 
            updateTurnUI(); 
            if (gameState.step === 'MOVE') { 
                document.getElementById('gaugeArea').style.display = 'none'; 
                document.getElementById('moveArea').style.display = 'block'; 
                updateAvailableMovesUI(); 
                renderTokenOptions(); 
            } else { 
                document.getElementById('gaugeArea').style.display = 'block'; 
                document.getElementById('moveArea').style.display = 'none'; 
                document.getElementById('actionBtn').disabled = false; 
                document.getElementById('actionBtn').innerText = gameState.moveQueue.length > 0 ? "ë˜ì§€ê¸° (ë³´ë„ˆìŠ¤)" : "ë˜ì§€ê¸° (START)"; 
            } 
        }
        function nextTurn(forcedIdx = null) { 
            if (aiTimeoutId) { clearTimeout(aiTimeoutId); aiTimeoutId = null; } 
            
            if (forcedIdx !== null) {
                gameState.currentTeamIdx = forcedIdx;
            } else {
                gameState.currentTeamIdx = (gameState.currentTeamIdx + 1) % teams.length; 
            }
            
            gameState.step = 'THROW'; gameState.moveQueue = []; gameState.selectedMoveId = null; 
            
            isCharging = false;
            power = 0;
            document.getElementById('powerBar').style.width = "0%";
            document.getElementById('availableMoves').innerHTML = ""; 
            document.getElementById('subResult').innerText = "ë²„íŠ¼ì„ ëˆŒëŸ¬ í˜ì„ ì¡°ì ˆí•˜ì„¸ìš”!"; 
            for(let i=0; i<4; i++) { sticks[i].className = 'stick round'; if(i===3) sticks[i].classList.add('back-do-mark'); }
            
            updateTurnUI(); 

            // ë°©ì¥ì€ í„´ì´ ë°”ë€” ë•Œë§ˆë‹¤ ì „ì²´ ìƒíƒœë¥¼ ê°•ì œ ë™ê¸°í™”í•˜ì—¬ ì „íŒŒ
            if (isOnlineMode && isHost) {
                setTimeout(syncGameState, 500);
            }
        }

        function syncGameState() {
            if (!isOnlineMode || !isHost) return;
            const stateData = {
                type: 'sync',
                teams: teams.map(t => ({
                    id: t.id,
                    sp: t.sp,
                    remainingUndos: t.remainingUndos,
                    tokens: t.tokens.map(tk => ({ ...tk }))
                })),
                currentTeamIdx: gameState.currentTeamIdx,
                step: gameState.step,
                moveQueue: gameState.moveQueue,
                traps: gameState.traps
            };
            broadcast(stateData);
        }

        function applySyncState(data) {
            if (isHost) return; // ë°©ì¥ì€ ë™ê¸°í™” ë°ì´í„°ë¥¼ ë°›ì§€ ì•ŠìŒ
            
            // íŒ€ ë° ë§ ìƒíƒœ ì—…ë°ì´íŠ¸
            data.teams.forEach((remoteTeam, i) => {
                if (teams[i]) {
                    teams[i].sp = remoteTeam.sp;
                    teams[i].remainingUndos = remoteTeam.remainingUndos;
                    // ë§ ìœ„ì¹˜ ë™ê¸°í™”
                    remoteTeam.tokens.forEach((remoteToken, j) => {
                        if (teams[i].tokens[j]) {
                            teams[i].tokens[j].index = remoteToken.index;
                            teams[i].tokens[j].location = remoteToken.location;
                            teams[i].tokens[j].finished = remoteToken.finished;
                            teams[i].tokens[j].shielded = remoteToken.shielded;
                        }
                    });
                }
            });

            // ê²Œì„ ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
            gameState.currentTeamIdx = data.currentTeamIdx;
            gameState.step = data.step;
            gameState.moveQueue = data.moveQueue || [];
            gameState.traps = data.traps || [];

            updateBoardVisuals();
            updateTurnUI();
            
            // ì´ë™ ëŒ€ê¸° ì¤‘ì¸ ê²½ìš° UI ì—…ë°ì´íŠ¸
            if (gameState.step === 'MOVE' && gameState.moveQueue.length > 0) {
                updateAvailableMovesUI();
                renderTokenOptions();
            }
        }
        function showMessage(msg, color) { 
            showToast(msg, "");
            document.getElementById('subResult').innerText = ""; 
        }
        function updateTurnUI() { 
            const team = teams[gameState.currentTeamIdx]; if (!team) return; 
            
            // ë‚´ ì°¨ë¡€ì¸ì§€ í™•ì¸
            const isMyTurn = !isOnlineMode || gameState.currentTeamIdx === myTeamIdx;

            // ìŠ¤í‚¬ ì„ íƒ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì•ˆë‚´ ì˜ì—­ì„ ë¹„ì›€ (ë˜ì§€ê¸° ë‹¨ê³„ì—ì„œ ì”ìƒ ë°©ì§€)
            if (!gameState.selectedSkillType && gameState.step === 'THROW') {
                document.getElementById('availableMoves').innerHTML = "";
            }

            document.getElementById('turnIndicator').innerText = `${team.name}${team.isAi ? ' (AI)' : ''} ì°¨ë¡€`; 
            document.getElementById('turnIndicator').style.backgroundColor = team.color; 
            document.getElementById('actionBtn').style.backgroundColor = team.color; 
            
            if (isPowerUpMode) { 
                document.getElementById('spDisplay').textContent = `SP: ${team.sp || 0}`; 
                document.getElementById('spDisplay').style.display = 'inline'; 
                document.getElementById('skillArea').style.display = 'flex'; 
                // ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆë©´ ìŠ¤í‚¬ ë²„íŠ¼ ë¹„í™œì„±í™”
                document.getElementById('skillShield').disabled = !isMyTurn || team.sp < 1 || team.isAi || !team.tokens.some(t => t.index > 0 && !t.finished && !t.shielded); 
                document.getElementById('skillReroll').disabled = !isMyTurn || team.sp < 1 || team.isAi || !(gameState.step === 'MOVE' && gameState.moveQueue.length > 0); 
                document.getElementById('skillBoost').disabled = !isMyTurn || team.sp < 2 || team.isAi || !team.tokens.some(t => !t.finished); 
            } else { 
                document.getElementById('spDisplay').style.display = 'none'; 
                document.getElementById('skillArea').style.display = 'none'; 
            } 
            
            if (gameState.step === 'THROW') {
                document.getElementById('moveArea').style.display = 'none';
                document.getElementById('gaugeArea').style.display = 'block'; 
                document.getElementById('actionBtn').style.display = 'block';
                if (team.isAi) {
                    document.getElementById('actionBtn').disabled = true; 
                    document.getElementById('actionBtn').innerText = "AI ì°¨ë¡€ (ì¤€ë¹„ ì¤‘...)"; 
                } else if (!isMyTurn) {
                    // ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œ ìƒëŒ€ë°© ì°¨ë¡€ì¼ ë•Œ ë²„íŠ¼ ë¹„í™œì„±í™”
                    document.getElementById('actionBtn').disabled = true; 
                    document.getElementById('actionBtn').innerText = "ìƒëŒ€ë°© ì°¨ë¡€..."; 
                    document.getElementById('actionBtn').style.backgroundColor = "#ccc";
                } else {
                    document.getElementById('actionBtn').disabled = false; 
                    document.getElementById('actionBtn').innerText = gameState.moveQueue.length > 0 ? "ë˜ì§€ê¸° (ë³´ë„ˆìŠ¤)" : "ë˜ì§€ê¸° (START)"; 
                }
            } else { 
                document.getElementById('gaugeArea').style.display = 'none'; 
                document.getElementById('moveArea').style.display = 'block';
                document.getElementById('actionBtn').style.display = 'none';
            } 
            optimizeLayout();
            maybeTriggerAi(); 
        }
        const outerP = [{x:350,y:350},{x:350,y:290},{x:350,y:230},{x:350,y:170},{x:350,y:110},{x:350,y:50},{x:290,y:50},{x:230,y:50},{x:170,y:50},{x:110,y:50},{x:50,y:50},{x:50,y:110},{x:50,y:170},{x:50,y:230},{x:50,y:290},{x:50,y:350},{x:110,y:350},{x:170,y:350},{x:230,y:350},{x:290,y:350},{x:350,y:350}];
        function getCoords(i, l) { if (l === 'shortcut_1') { if (i === 5) return outerP[5]; const m = { 21:{x:300,y:100}, 22:{x:250,y:150}, 23:{x:200,y:200}, 24:{x:150,y:250}, 25:{x:100,y:300} }; return m[i] || outerP[i]; } if (l === 'shortcut_2') { if (i === 10) return outerP[10]; const m = { 26:{x:100,y:100}, 27:{x:150,y:150}, 23:{x:200,y:200}, 28:{x:250,y:250}, 29:{x:300,y:300} }; return m[i] || outerP[i]; } return outerP[i]; }
        function drawBoardDots() { 
            document.getElementById('boardDots').innerHTML = ""; 
            outerP.forEach((p, i) => { if (i<20) createDot(p.x, p.y, i); }); 
            createDot(300,100,21); createDot(250,150,22); createDot(200,200,'center'); createDot(150,250,24); createDot(100,300,25); createDot(100,100,26); createDot(150,150,27); createDot(250,250,28); createDot(300,300,29); 

            // í•¨ì • ì‹œê°ì  í‘œì‹œ ê°•í™”
            if (gameState.traps) {
                gameState.traps.forEach(tr => {
                    const pos = getCoords(tr.index, tr.loc);
                    
                    // ê²€ì€ìƒ‰ ê°•ì¡° ì› ì¶”ê°€
                    const trapCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    trapCircle.setAttribute("cx", pos.x);
                    trapCircle.setAttribute("cy", pos.y);
                    trapCircle.setAttribute("r", 9); // ì¼ë°˜ ì (7)ë³´ë‹¤ í¬ê²Œ
                    trapCircle.setAttribute("fill", "#1d1d1f"); // Apple Black
                    trapCircle.setAttribute("stroke", "#ff3b30"); // ê²½ê³ ìš© ë¹¨ê°„ í…Œë‘ë¦¬
                    trapCircle.setAttribute("stroke-width", "1.5");
                    document.getElementById('boardDots').appendChild(trapCircle);

                    // ê±°ë¯¸ì¤„ ì•„ì´ì½˜
                    const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    txt.setAttribute("x", pos.x);
                    txt.setAttribute("y", pos.y + 4);
                    txt.setAttribute("font-size", "11");
                    txt.setAttribute("text-anchor", "middle");
                    txt.setAttribute("style", "pointer-events: none;");
                    txt.textContent = "ğŸ•¸ï¸";
                    document.getElementById('boardDots').appendChild(txt);

                    // "í•¨ì •!" í…ìŠ¤íŠ¸ ì¶”ê°€
                    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    label.setAttribute("x", pos.x);
                    label.setAttribute("y", pos.y + 20); // ì  ì•„ë˜ìª½ì— ë°°ì¹˜
                    label.setAttribute("font-size", "8");
                    label.setAttribute("font-weight", "800");
                    label.setAttribute("text-anchor", "middle");
                    label.setAttribute("fill", "#ff3b30"); // ê²½ê³  ë¹¨ê°„ìƒ‰
                    label.setAttribute("style", "pointer-events: none; letter-spacing: -0.5px;");
                    label.textContent = "í•¨ì •!";
                    document.getElementById('boardDots').appendChild(label);
                });
            }
        }
        function createDot(cx, cy, id) { const c = document.createElementNS("http://www.w3.org/2000/svg", "circle"); c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", 7); c.setAttribute("class", "board-dot" + (id===0?' start':(id==='center'?' center':([5,10,15].includes(id)?' corner':'')))); document.getElementById('boardDots').appendChild(c); }
        const sticks = document.getElementById('yutContainer').children;
        initSetup();

        if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/service-worker.js'); }); }
    </script>
</body>
</html>
